// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateDaoSchema generate files should be match to snapshots 1`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';

export default class SurveyDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'survey',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  survey(context: any, where: openCrudSchema.QuerySurveyArgs['where']): Promise<openCrudSchema.Query['survey']> {
    return this.entityDAO.survey(context, where);
  }

  surveyById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['survey']> {
    return this.entityDAO.surveyById(context, id);
  }

  surveys(context: any, args: openCrudSchema.QuerySurveysArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['surveys']> {
    return this.entityDAO.surveys(context, args);
  }

  surveysByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['surveys']> {
    return this.entityDAO.surveysByIds(context, ids);
  }

  createSurvey(context: any, data: openCrudSchema.MutationCreateSurveyArgs['data']): Promise<openCrudSchema.Mutation['createSurvey']> {
    return this.entityDAO.createSurvey(context, data);
  }

  updateSurvey(context: any, args: openCrudSchema.MutationUpdateSurveyArgs): Promise<openCrudSchema.Mutation['updateSurvey']> {
    return this.entityDAO.updateSurvey(context, args);
  }

  updateManySurveys(context: any, args: openCrudSchema.MutationUpdateManySurveysArgs): Promise<openCrudSchema.Mutation['updateManySurveys']> {
    return this.entityDAO.updateManySurveys(context, args);
  }

  deleteSurvey(context: any, where: openCrudSchema.MutationDeleteSurveyArgs['where']): Promise<openCrudSchema.Mutation['deleteSurvey']> {
    return this.entityDAO.deleteSurvey(context, where);
  }

  deleteManySurveys(context: any, where: openCrudSchema.MutationDeleteManySurveysArgs['where']): Promise<openCrudSchema.Mutation['deleteManySurveys']> {
    return this.entityDAO.deleteManySurveys(context, where);
  }

  surveysConnection(parent: any, args: openCrudSchema.QuerySurveysConnectionArgs, context: any): Promise<openCrudSchema.Query['surveysConnection']> {
    return this.entityDAO.surveysConnection(parent, args, context);
  }

  getRelatedEntityId: async (originalEntityId: string, relationEntityName: string) => {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName);
  }

  getRelatedEntity: async (originalEntityId: string, relationEntityName: string) => {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName);
  }

  getRelatedEntityIds: async (originalEntityId: string, relationEntityName: string, args?: any) => {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, args);
  }

  getRelatedEntities: async (originalEntityId: string, relationEntityName: string, args?: any) => {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, args);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 2`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';

export default class SurveyQuestionDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'surveyQuestion',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  surveyQuestion(context: any, where: openCrudSchema.QuerySurveyQuestionArgs['where']): Promise<openCrudSchema.Query['surveyQuestion']> {
    return this.entityDAO.surveyQuestion(context, where);
  }

  surveyQuestionById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['surveyQuestion']> {
    return this.entityDAO.surveyQuestionById(context, id);
  }

  surveyQuestions(context: any, args: openCrudSchema.QuerySurveyQuestionsArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['surveyQuestions']> {
    return this.entityDAO.surveyQuestions(context, args);
  }

  surveyQuestionsByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['surveyQuestions']> {
    return this.entityDAO.surveyQuestionsByIds(context, ids);
  }

  createSurveyQuestion(context: any, data: openCrudSchema.MutationCreateSurveyQuestionArgs['data']): Promise<openCrudSchema.Mutation['createSurveyQuestion']> {
    return this.entityDAO.createSurveyQuestion(context, data);
  }

  updateSurveyQuestion(context: any, args: openCrudSchema.MutationUpdateSurveyQuestionArgs): Promise<openCrudSchema.Mutation['updateSurveyQuestion']> {
    return this.entityDAO.updateSurveyQuestion(context, args);
  }

  updateManySurveyQuestions(context: any, args: openCrudSchema.MutationUpdateManySurveyQuestionsArgs): Promise<openCrudSchema.Mutation['updateManySurveyQuestions']> {
    return this.entityDAO.updateManySurveyQuestions(context, args);
  }

  deleteSurveyQuestion(context: any, where: openCrudSchema.MutationDeleteSurveyQuestionArgs['where']): Promise<openCrudSchema.Mutation['deleteSurveyQuestion']> {
    return this.entityDAO.deleteSurveyQuestion(context, where);
  }

  deleteManySurveyQuestions(context: any, where: openCrudSchema.MutationDeleteManySurveyQuestionsArgs['where']): Promise<openCrudSchema.Mutation['deleteManySurveyQuestions']> {
    return this.entityDAO.deleteManySurveyQuestions(context, where);
  }

  surveyQuestionsConnection(parent: any, args: openCrudSchema.QuerySurveyQuestionsConnectionArgs, context: any): Promise<openCrudSchema.Query['surveyQuestionsConnection']> {
    return this.entityDAO.surveyQuestionsConnection(parent, args, context);
  }

  getRelatedEntityId: async (originalEntityId: string, relationEntityName: string) => {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName);
  }

  getRelatedEntity: async (originalEntityId: string, relationEntityName: string) => {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName);
  }

  getRelatedEntityIds: async (originalEntityId: string, relationEntityName: string, args?: any) => {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, args);
  }

  getRelatedEntities: async (originalEntityId: string, relationEntityName: string, args?: any) => {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, args);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 3`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';

export default class SurveyQuestionResponseDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'surveyQuestionResponse',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  surveyQuestionResponse(context: any, where: openCrudSchema.QuerySurveyQuestionResponseArgs['where']): Promise<openCrudSchema.Query['surveyQuestionResponse']> {
    return this.entityDAO.surveyQuestionResponse(context, where);
  }

  surveyQuestionResponseById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['surveyQuestionResponse']> {
    return this.entityDAO.surveyQuestionResponseById(context, id);
  }

  surveyQuestionResponses(context: any, args: openCrudSchema.QuerySurveyQuestionResponsesArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['surveyQuestionResponses']> {
    return this.entityDAO.surveyQuestionResponses(context, args);
  }

  surveyQuestionResponsesByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['surveyQuestionResponses']> {
    return this.entityDAO.surveyQuestionResponsesByIds(context, ids);
  }

  createSurveyQuestionResponse(context: any, data: openCrudSchema.MutationCreateSurveyQuestionResponseArgs['data']): Promise<openCrudSchema.Mutation['createSurveyQuestionResponse']> {
    return this.entityDAO.createSurveyQuestionResponse(context, data);
  }

  updateSurveyQuestionResponse(context: any, args: openCrudSchema.MutationUpdateSurveyQuestionResponseArgs): Promise<openCrudSchema.Mutation['updateSurveyQuestionResponse']> {
    return this.entityDAO.updateSurveyQuestionResponse(context, args);
  }

  updateManySurveyQuestionResponses(context: any, args: openCrudSchema.MutationUpdateManySurveyQuestionResponsesArgs): Promise<openCrudSchema.Mutation['updateManySurveyQuestionResponses']> {
    return this.entityDAO.updateManySurveyQuestionResponses(context, args);
  }

  deleteSurveyQuestionResponse(context: any, where: openCrudSchema.MutationDeleteSurveyQuestionResponseArgs['where']): Promise<openCrudSchema.Mutation['deleteSurveyQuestionResponse']> {
    return this.entityDAO.deleteSurveyQuestionResponse(context, where);
  }

  deleteManySurveyQuestionResponses(context: any, where: openCrudSchema.MutationDeleteManySurveyQuestionResponsesArgs['where']): Promise<openCrudSchema.Mutation['deleteManySurveyQuestionResponses']> {
    return this.entityDAO.deleteManySurveyQuestionResponses(context, where);
  }

  surveyQuestionResponsesConnection(parent: any, args: openCrudSchema.QuerySurveyQuestionResponsesConnectionArgs, context: any): Promise<openCrudSchema.Query['surveyQuestionResponsesConnection']> {
    return this.entityDAO.surveyQuestionResponsesConnection(parent, args, context);
  }

  getRelatedEntityId: async (originalEntityId: string, relationEntityName: string) => {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName);
  }

  getRelatedEntity: async (originalEntityId: string, relationEntityName: string) => {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName);
  }

  getRelatedEntityIds: async (originalEntityId: string, relationEntityName: string, args?: any) => {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, args);
  }

  getRelatedEntities: async (originalEntityId: string, relationEntityName: string, args?: any) => {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, args);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 4`] = `
"export * from './openCrudSchema';
export * from './whiteListOpenCrudSchema';
export { default as SurveyDAO } from './SurveyDAO';
export { default as SurveyQuestionDAO } from './SurveyQuestionDAO';
export { default as SurveyQuestionResponseDAO } from './SurveyQuestionResponseDAO';
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 5`] = `
"type AggregateSurvey {
  count: Int!
}

type AggregateSurveyQuestion {
  count: Int!
}

type AggregateSurveyQuestionResponse {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Json

scalar Long

type Mutation {
  createSurvey(data: SurveyCreateInput!): Survey!
  updateSurvey(data: SurveyUpdateInput!, where: SurveyWhereUniqueInput!): Survey
  updateManySurveys(data: SurveyUpdateManyMutationInput!, where: SurveyWhereInput): BatchPayload!
  upsertSurvey(where: SurveyWhereUniqueInput!, create: SurveyCreateInput!, update: SurveyUpdateInput!): Survey!
  deleteSurvey(where: SurveyWhereUniqueInput!): Survey
  deleteManySurveys(where: SurveyWhereInput): BatchPayload!
  createSurveyQuestion(data: SurveyQuestionCreateInput!): SurveyQuestion!
  updateSurveyQuestion(data: SurveyQuestionUpdateInput!, where: SurveyQuestionWhereUniqueInput!): SurveyQuestion
  updateManySurveyQuestions(data: SurveyQuestionUpdateManyMutationInput!, where: SurveyQuestionWhereInput): BatchPayload!
  upsertSurveyQuestion(where: SurveyQuestionWhereUniqueInput!, create: SurveyQuestionCreateInput!, update: SurveyQuestionUpdateInput!): SurveyQuestion!
  deleteSurveyQuestion(where: SurveyQuestionWhereUniqueInput!): SurveyQuestion
  deleteManySurveyQuestions(where: SurveyQuestionWhereInput): BatchPayload!
  createSurveyQuestionResponse(data: SurveyQuestionResponseCreateInput!): SurveyQuestionResponse!
  updateSurveyQuestionResponse(data: SurveyQuestionResponseUpdateInput!, where: SurveyQuestionResponseWhereUniqueInput!): SurveyQuestionResponse
  updateManySurveyQuestionResponses(data: SurveyQuestionResponseUpdateManyMutationInput!, where: SurveyQuestionResponseWhereInput): BatchPayload!
  upsertSurveyQuestionResponse(where: SurveyQuestionResponseWhereUniqueInput!, create: SurveyQuestionResponseCreateInput!, update: SurveyQuestionResponseUpdateInput!): SurveyQuestionResponse!
  deleteSurveyQuestionResponse(where: SurveyQuestionResponseWhereUniqueInput!): SurveyQuestionResponse
  deleteManySurveyQuestionResponses(where: SurveyQuestionResponseWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  survey(where: SurveyWhereUniqueInput!): Survey
  surveys(where: SurveyWhereInput, orderBy: SurveyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Survey!]!
  surveysConnection(where: SurveyWhereInput, orderBy: SurveyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SurveyConnection!
  surveyQuestion(where: SurveyQuestionWhereUniqueInput!): SurveyQuestion
  surveyQuestions(where: SurveyQuestionWhereInput, orderBy: SurveyQuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SurveyQuestion!]!
  surveyQuestionsConnection(where: SurveyQuestionWhereInput, orderBy: SurveyQuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SurveyQuestionConnection!
  surveyQuestionResponse(where: SurveyQuestionResponseWhereUniqueInput!): SurveyQuestionResponse
  surveyQuestionResponses(where: SurveyQuestionResponseWhereInput, orderBy: SurveyQuestionResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SurveyQuestionResponse!]!
  surveyQuestionResponsesConnection(where: SurveyQuestionResponseWhereInput, orderBy: SurveyQuestionResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SurveyQuestionResponseConnection!
  node(id: ID!): Node
}

type Subscription {
  survey(where: SurveySubscriptionWhereInput): SurveySubscriptionPayload
  surveyQuestion(where: SurveyQuestionSubscriptionWhereInput): SurveyQuestionSubscriptionPayload
  surveyQuestionResponse(where: SurveyQuestionResponseSubscriptionWhereInput): SurveyQuestionResponseSubscriptionPayload
}

type Survey {
  id: ID!
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  questions(where: SurveyQuestionWhereInput, orderBy: SurveyQuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SurveyQuestion!]
  hoodId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

enum SURVEY_RESPONSES {
  VERY_HAPPY
  HAPPY
  SAD
  VERY_SAD
}

type SurveyConnection {
  pageInfo: PageInfo!
  edges: [SurveyEdge]!
  aggregate: AggregateSurvey!
}

input SurveyCreateInput {
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  questions: SurveyQuestionCreateManyWithoutSurveyInput
  hoodId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyCreateOneWithoutQuestionsInput {
  create: SurveyCreateWithoutQuestionsInput
  connect: SurveyWhereUniqueInput
}

input SurveyCreateWithoutQuestionsInput {
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  hoodId: String
  deletedAt: DateTime
  deleted: Int
}

type SurveyEdge {
  node: Survey!
  cursor: String!
}

enum SurveyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  enabled_ASC
  enabled_DESC
  isAnonymous_ASC
  isAnonymous_DESC
  hoodId_ASC
  hoodId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type SurveyPreviousValues {
  id: ID!
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  hoodId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type SurveyQuestion {
  id: ID!
  text: String
  options: Json
  addCommentField: Boolean
  responses(where: SurveyQuestionResponseWhereInput, orderBy: SurveyQuestionResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SurveyQuestionResponse!]
  survey: Survey!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type SurveyQuestionConnection {
  pageInfo: PageInfo!
  edges: [SurveyQuestionEdge]!
  aggregate: AggregateSurveyQuestion!
}

input SurveyQuestionCreateInput {
  text: String
  options: Json
  addCommentField: Boolean
  responses: SurveyQuestionResponseCreateManyWithoutQuestionInput
  survey: SurveyCreateOneWithoutQuestionsInput!
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionCreateManyWithoutSurveyInput {
  create: [SurveyQuestionCreateWithoutSurveyInput!]
  connect: [SurveyQuestionWhereUniqueInput!]
}

input SurveyQuestionCreateOneWithoutResponsesInput {
  create: SurveyQuestionCreateWithoutResponsesInput
  connect: SurveyQuestionWhereUniqueInput
}

input SurveyQuestionCreateWithoutResponsesInput {
  text: String
  options: Json
  addCommentField: Boolean
  survey: SurveyCreateOneWithoutQuestionsInput!
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionCreateWithoutSurveyInput {
  text: String
  options: Json
  addCommentField: Boolean
  responses: SurveyQuestionResponseCreateManyWithoutQuestionInput
  deletedAt: DateTime
  deleted: Int
}

type SurveyQuestionEdge {
  node: SurveyQuestion!
  cursor: String!
}

enum SurveyQuestionOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  options_ASC
  options_DESC
  addCommentField_ASC
  addCommentField_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type SurveyQuestionPreviousValues {
  id: ID!
  text: String
  options: Json
  addCommentField: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type SurveyQuestionResponse {
  id: ID!
  value: SURVEY_RESPONSES
  comment: String
  question: SurveyQuestion!
  responderId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type SurveyQuestionResponseConnection {
  pageInfo: PageInfo!
  edges: [SurveyQuestionResponseEdge]!
  aggregate: AggregateSurveyQuestionResponse!
}

input SurveyQuestionResponseCreateInput {
  value: SURVEY_RESPONSES
  comment: String
  question: SurveyQuestionCreateOneWithoutResponsesInput!
  responderId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionResponseCreateManyWithoutQuestionInput {
  create: [SurveyQuestionResponseCreateWithoutQuestionInput!]
  connect: [SurveyQuestionResponseWhereUniqueInput!]
}

input SurveyQuestionResponseCreateWithoutQuestionInput {
  value: SURVEY_RESPONSES
  comment: String
  responderId: String
  deletedAt: DateTime
  deleted: Int
}

type SurveyQuestionResponseEdge {
  node: SurveyQuestionResponse!
  cursor: String!
}

enum SurveyQuestionResponseOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  comment_ASC
  comment_DESC
  responderId_ASC
  responderId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type SurveyQuestionResponsePreviousValues {
  id: ID!
  value: SURVEY_RESPONSES
  comment: String
  responderId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input SurveyQuestionResponseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: SURVEY_RESPONSES
  value_not: SURVEY_RESPONSES
  value_in: [SURVEY_RESPONSES!]
  value_not_in: [SURVEY_RESPONSES!]
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  responderId: String
  responderId_not: String
  responderId_in: [String!]
  responderId_not_in: [String!]
  responderId_lt: String
  responderId_lte: String
  responderId_gt: String
  responderId_gte: String
  responderId_contains: String
  responderId_not_contains: String
  responderId_starts_with: String
  responderId_not_starts_with: String
  responderId_ends_with: String
  responderId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyQuestionResponseScalarWhereInput!]
  OR: [SurveyQuestionResponseScalarWhereInput!]
  NOT: [SurveyQuestionResponseScalarWhereInput!]
}

type SurveyQuestionResponseSubscriptionPayload {
  mutation: MutationType!
  node: SurveyQuestionResponse
  updatedFields: [String!]
  previousValues: SurveyQuestionResponsePreviousValues
}

input SurveyQuestionResponseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SurveyQuestionResponseWhereInput
  AND: [SurveyQuestionResponseSubscriptionWhereInput!]
  OR: [SurveyQuestionResponseSubscriptionWhereInput!]
  NOT: [SurveyQuestionResponseSubscriptionWhereInput!]
}

input SurveyQuestionResponseUpdateInput {
  value: SURVEY_RESPONSES
  comment: String
  question: SurveyQuestionUpdateOneRequiredWithoutResponsesInput
  responderId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionResponseUpdateManyDataInput {
  value: SURVEY_RESPONSES
  comment: String
  responderId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionResponseUpdateManyMutationInput {
  value: SURVEY_RESPONSES
  comment: String
  responderId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionResponseUpdateManyWithoutQuestionInput {
  create: [SurveyQuestionResponseCreateWithoutQuestionInput!]
  delete: [SurveyQuestionResponseWhereUniqueInput!]
  connect: [SurveyQuestionResponseWhereUniqueInput!]
  set: [SurveyQuestionResponseWhereUniqueInput!]
  disconnect: [SurveyQuestionResponseWhereUniqueInput!]
  update: [SurveyQuestionResponseUpdateWithWhereUniqueWithoutQuestionInput!]
  upsert: [SurveyQuestionResponseUpsertWithWhereUniqueWithoutQuestionInput!]
  deleteMany: [SurveyQuestionResponseScalarWhereInput!]
  updateMany: [SurveyQuestionResponseUpdateManyWithWhereNestedInput!]
}

input SurveyQuestionResponseUpdateManyWithWhereNestedInput {
  where: SurveyQuestionResponseScalarWhereInput!
  data: SurveyQuestionResponseUpdateManyDataInput!
}

input SurveyQuestionResponseUpdateWithoutQuestionDataInput {
  value: SURVEY_RESPONSES
  comment: String
  responderId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionResponseUpdateWithWhereUniqueWithoutQuestionInput {
  where: SurveyQuestionResponseWhereUniqueInput!
  data: SurveyQuestionResponseUpdateWithoutQuestionDataInput!
}

input SurveyQuestionResponseUpsertWithWhereUniqueWithoutQuestionInput {
  where: SurveyQuestionResponseWhereUniqueInput!
  update: SurveyQuestionResponseUpdateWithoutQuestionDataInput!
  create: SurveyQuestionResponseCreateWithoutQuestionInput!
}

input SurveyQuestionResponseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: SURVEY_RESPONSES
  value_not: SURVEY_RESPONSES
  value_in: [SURVEY_RESPONSES!]
  value_not_in: [SURVEY_RESPONSES!]
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  question: SurveyQuestionWhereInput
  responderId: String
  responderId_not: String
  responderId_in: [String!]
  responderId_not_in: [String!]
  responderId_lt: String
  responderId_lte: String
  responderId_gt: String
  responderId_gte: String
  responderId_contains: String
  responderId_not_contains: String
  responderId_starts_with: String
  responderId_not_starts_with: String
  responderId_ends_with: String
  responderId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyQuestionResponseWhereInput!]
  OR: [SurveyQuestionResponseWhereInput!]
  NOT: [SurveyQuestionResponseWhereInput!]
}

input SurveyQuestionResponseWhereUniqueInput {
  id: ID
}

input SurveyQuestionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  addCommentField: Boolean
  addCommentField_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyQuestionScalarWhereInput!]
  OR: [SurveyQuestionScalarWhereInput!]
  NOT: [SurveyQuestionScalarWhereInput!]
}

type SurveyQuestionSubscriptionPayload {
  mutation: MutationType!
  node: SurveyQuestion
  updatedFields: [String!]
  previousValues: SurveyQuestionPreviousValues
}

input SurveyQuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SurveyQuestionWhereInput
  AND: [SurveyQuestionSubscriptionWhereInput!]
  OR: [SurveyQuestionSubscriptionWhereInput!]
  NOT: [SurveyQuestionSubscriptionWhereInput!]
}

input SurveyQuestionUpdateInput {
  text: String
  options: Json
  addCommentField: Boolean
  responses: SurveyQuestionResponseUpdateManyWithoutQuestionInput
  survey: SurveyUpdateOneRequiredWithoutQuestionsInput
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionUpdateManyDataInput {
  text: String
  options: Json
  addCommentField: Boolean
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionUpdateManyMutationInput {
  text: String
  options: Json
  addCommentField: Boolean
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionUpdateManyWithoutSurveyInput {
  create: [SurveyQuestionCreateWithoutSurveyInput!]
  delete: [SurveyQuestionWhereUniqueInput!]
  connect: [SurveyQuestionWhereUniqueInput!]
  set: [SurveyQuestionWhereUniqueInput!]
  disconnect: [SurveyQuestionWhereUniqueInput!]
  update: [SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput!]
  upsert: [SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput!]
  deleteMany: [SurveyQuestionScalarWhereInput!]
  updateMany: [SurveyQuestionUpdateManyWithWhereNestedInput!]
}

input SurveyQuestionUpdateManyWithWhereNestedInput {
  where: SurveyQuestionScalarWhereInput!
  data: SurveyQuestionUpdateManyDataInput!
}

input SurveyQuestionUpdateOneRequiredWithoutResponsesInput {
  create: SurveyQuestionCreateWithoutResponsesInput
  update: SurveyQuestionUpdateWithoutResponsesDataInput
  upsert: SurveyQuestionUpsertWithoutResponsesInput
  connect: SurveyQuestionWhereUniqueInput
}

input SurveyQuestionUpdateWithoutResponsesDataInput {
  text: String
  options: Json
  addCommentField: Boolean
  survey: SurveyUpdateOneRequiredWithoutQuestionsInput
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionUpdateWithoutSurveyDataInput {
  text: String
  options: Json
  addCommentField: Boolean
  responses: SurveyQuestionResponseUpdateManyWithoutQuestionInput
  deletedAt: DateTime
  deleted: Int
}

input SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput {
  where: SurveyQuestionWhereUniqueInput!
  data: SurveyQuestionUpdateWithoutSurveyDataInput!
}

input SurveyQuestionUpsertWithoutResponsesInput {
  update: SurveyQuestionUpdateWithoutResponsesDataInput!
  create: SurveyQuestionCreateWithoutResponsesInput!
}

input SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput {
  where: SurveyQuestionWhereUniqueInput!
  update: SurveyQuestionUpdateWithoutSurveyDataInput!
  create: SurveyQuestionCreateWithoutSurveyInput!
}

input SurveyQuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  addCommentField: Boolean
  addCommentField_not: Boolean
  responses_every: SurveyQuestionResponseWhereInput
  responses_some: SurveyQuestionResponseWhereInput
  responses_none: SurveyQuestionResponseWhereInput
  survey: SurveyWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyQuestionWhereInput!]
  OR: [SurveyQuestionWhereInput!]
  NOT: [SurveyQuestionWhereInput!]
}

input SurveyQuestionWhereUniqueInput {
  id: ID
}

type SurveySubscriptionPayload {
  mutation: MutationType!
  node: Survey
  updatedFields: [String!]
  previousValues: SurveyPreviousValues
}

input SurveySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SurveyWhereInput
  AND: [SurveySubscriptionWhereInput!]
  OR: [SurveySubscriptionWhereInput!]
  NOT: [SurveySubscriptionWhereInput!]
}

input SurveyUpdateInput {
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  questions: SurveyQuestionUpdateManyWithoutSurveyInput
  hoodId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyUpdateManyMutationInput {
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  hoodId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyUpdateOneRequiredWithoutQuestionsInput {
  create: SurveyCreateWithoutQuestionsInput
  update: SurveyUpdateWithoutQuestionsDataInput
  upsert: SurveyUpsertWithoutQuestionsInput
  connect: SurveyWhereUniqueInput
}

input SurveyUpdateWithoutQuestionsDataInput {
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  hoodId: String
  deletedAt: DateTime
  deleted: Int
}

input SurveyUpsertWithoutQuestionsInput {
  update: SurveyUpdateWithoutQuestionsDataInput!
  create: SurveyCreateWithoutQuestionsInput!
}

input SurveyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  enabled: Boolean
  enabled_not: Boolean
  isAnonymous: Boolean
  isAnonymous_not: Boolean
  questions_every: SurveyQuestionWhereInput
  questions_some: SurveyQuestionWhereInput
  questions_none: SurveyQuestionWhereInput
  hoodId: String
  hoodId_not: String
  hoodId_in: [String!]
  hoodId_not_in: [String!]
  hoodId_lt: String
  hoodId_lte: String
  hoodId_gt: String
  hoodId_gte: String
  hoodId_contains: String
  hoodId_not_contains: String
  hoodId_starts_with: String
  hoodId_not_starts_with: String
  hoodId_ends_with: String
  hoodId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyWhereInput!]
  OR: [SurveyWhereInput!]
  NOT: [SurveyWhereInput!]
}

input SurveyWhereUniqueInput {
  id: ID
  name: String
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 6`] = `
"export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string,
  String: string,
  Boolean: boolean,
  Int: number,
  Float: number,
  DateTime: any,
  Json: any,
  Long: any,
};

export type AggregateSurvey = {
   __typename?: 'AggregateSurvey',
  count: Scalars['Int'],
};

export type AggregateSurveyQuestion = {
   __typename?: 'AggregateSurveyQuestion',
  count: Scalars['Int'],
};

export type AggregateSurveyQuestionResponse = {
   __typename?: 'AggregateSurveyQuestionResponse',
  count: Scalars['Int'],
};

export type BatchPayload = {
   __typename?: 'BatchPayload',
  count: Scalars['Long'],
};




export type Mutation = {
   __typename?: 'Mutation',
  createSurvey: Survey,
  updateSurvey?: Maybe<Survey>,
  updateManySurveys: BatchPayload,
  upsertSurvey: Survey,
  deleteSurvey?: Maybe<Survey>,
  deleteManySurveys: BatchPayload,
  createSurveyQuestion: SurveyQuestion,
  updateSurveyQuestion?: Maybe<SurveyQuestion>,
  updateManySurveyQuestions: BatchPayload,
  upsertSurveyQuestion: SurveyQuestion,
  deleteSurveyQuestion?: Maybe<SurveyQuestion>,
  deleteManySurveyQuestions: BatchPayload,
  createSurveyQuestionResponse: SurveyQuestionResponse,
  updateSurveyQuestionResponse?: Maybe<SurveyQuestionResponse>,
  updateManySurveyQuestionResponses: BatchPayload,
  upsertSurveyQuestionResponse: SurveyQuestionResponse,
  deleteSurveyQuestionResponse?: Maybe<SurveyQuestionResponse>,
  deleteManySurveyQuestionResponses: BatchPayload,
};


export type MutationCreateSurveyArgs = {
  data: SurveyCreateInput
};


export type MutationUpdateSurveyArgs = {
  data: SurveyUpdateInput,
  where: SurveyWhereUniqueInput
};


export type MutationUpdateManySurveysArgs = {
  data: SurveyUpdateManyMutationInput,
  where?: Maybe<SurveyWhereInput>
};


export type MutationUpsertSurveyArgs = {
  where: SurveyWhereUniqueInput,
  create: SurveyCreateInput,
  update: SurveyUpdateInput
};


export type MutationDeleteSurveyArgs = {
  where: SurveyWhereUniqueInput
};


export type MutationDeleteManySurveysArgs = {
  where?: Maybe<SurveyWhereInput>
};


export type MutationCreateSurveyQuestionArgs = {
  data: SurveyQuestionCreateInput
};


export type MutationUpdateSurveyQuestionArgs = {
  data: SurveyQuestionUpdateInput,
  where: SurveyQuestionWhereUniqueInput
};


export type MutationUpdateManySurveyQuestionsArgs = {
  data: SurveyQuestionUpdateManyMutationInput,
  where?: Maybe<SurveyQuestionWhereInput>
};


export type MutationUpsertSurveyQuestionArgs = {
  where: SurveyQuestionWhereUniqueInput,
  create: SurveyQuestionCreateInput,
  update: SurveyQuestionUpdateInput
};


export type MutationDeleteSurveyQuestionArgs = {
  where: SurveyQuestionWhereUniqueInput
};


export type MutationDeleteManySurveyQuestionsArgs = {
  where?: Maybe<SurveyQuestionWhereInput>
};


export type MutationCreateSurveyQuestionResponseArgs = {
  data: SurveyQuestionResponseCreateInput
};


export type MutationUpdateSurveyQuestionResponseArgs = {
  data: SurveyQuestionResponseUpdateInput,
  where: SurveyQuestionResponseWhereUniqueInput
};


export type MutationUpdateManySurveyQuestionResponsesArgs = {
  data: SurveyQuestionResponseUpdateManyMutationInput,
  where?: Maybe<SurveyQuestionResponseWhereInput>
};


export type MutationUpsertSurveyQuestionResponseArgs = {
  where: SurveyQuestionResponseWhereUniqueInput,
  create: SurveyQuestionResponseCreateInput,
  update: SurveyQuestionResponseUpdateInput
};


export type MutationDeleteSurveyQuestionResponseArgs = {
  where: SurveyQuestionResponseWhereUniqueInput
};


export type MutationDeleteManySurveyQuestionResponsesArgs = {
  where?: Maybe<SurveyQuestionResponseWhereInput>
};

export enum MutationType {
  CREATED = 'CREATED',
  UPDATED = 'UPDATED',
  DELETED = 'DELETED'
}

export type Node = {
  id: Scalars['ID'],
};

export type PageInfo = {
   __typename?: 'PageInfo',
  hasNextPage: Scalars['Boolean'],
  hasPreviousPage: Scalars['Boolean'],
  startCursor?: Maybe<Scalars['String']>,
  endCursor?: Maybe<Scalars['String']>,
};

export type Query = {
   __typename?: 'Query',
  survey?: Maybe<Survey>,
  surveys: Array<Survey>,
  surveysConnection: SurveyConnection,
  surveyQuestion?: Maybe<SurveyQuestion>,
  surveyQuestions: Array<SurveyQuestion>,
  surveyQuestionsConnection: SurveyQuestionConnection,
  surveyQuestionResponse?: Maybe<SurveyQuestionResponse>,
  surveyQuestionResponses: Array<SurveyQuestionResponse>,
  surveyQuestionResponsesConnection: SurveyQuestionResponseConnection,
  node?: Maybe<Node>,
};


export type QuerySurveyArgs = {
  where: SurveyWhereUniqueInput
};


export type QuerySurveysArgs = {
  where?: Maybe<SurveyWhereInput>,
  orderBy?: Maybe<SurveyOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


export type QuerySurveysConnectionArgs = {
  where?: Maybe<SurveyWhereInput>,
  orderBy?: Maybe<SurveyOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


export type QuerySurveyQuestionArgs = {
  where: SurveyQuestionWhereUniqueInput
};


export type QuerySurveyQuestionsArgs = {
  where?: Maybe<SurveyQuestionWhereInput>,
  orderBy?: Maybe<SurveyQuestionOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


export type QuerySurveyQuestionsConnectionArgs = {
  where?: Maybe<SurveyQuestionWhereInput>,
  orderBy?: Maybe<SurveyQuestionOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


export type QuerySurveyQuestionResponseArgs = {
  where: SurveyQuestionResponseWhereUniqueInput
};


export type QuerySurveyQuestionResponsesArgs = {
  where?: Maybe<SurveyQuestionResponseWhereInput>,
  orderBy?: Maybe<SurveyQuestionResponseOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


export type QuerySurveyQuestionResponsesConnectionArgs = {
  where?: Maybe<SurveyQuestionResponseWhereInput>,
  orderBy?: Maybe<SurveyQuestionResponseOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};


export type QueryNodeArgs = {
  id: Scalars['ID']
};

export type Subscription = {
   __typename?: 'Subscription',
  survey?: Maybe<SurveySubscriptionPayload>,
  surveyQuestion?: Maybe<SurveyQuestionSubscriptionPayload>,
  surveyQuestionResponse?: Maybe<SurveyQuestionResponseSubscriptionPayload>,
};


export type SubscriptionSurveyArgs = {
  where?: Maybe<SurveySubscriptionWhereInput>
};


export type SubscriptionSurveyQuestionArgs = {
  where?: Maybe<SurveyQuestionSubscriptionWhereInput>
};


export type SubscriptionSurveyQuestionResponseArgs = {
  where?: Maybe<SurveyQuestionResponseSubscriptionWhereInput>
};

export type Survey = {
   __typename?: 'Survey',
  id: Scalars['ID'],
  name?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  questions?: Maybe<Array<SurveyQuestion>>,
  hoodId?: Maybe<Scalars['String']>,
  createdAt: Scalars['DateTime'],
  updatedAt: Scalars['DateTime'],
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted: Scalars['Int'],
};


export type SurveyQuestionsArgs = {
  where?: Maybe<SurveyQuestionWhereInput>,
  orderBy?: Maybe<SurveyQuestionOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

export enum SurveyResponses {
  VERY_HAPPY = 'VERY_HAPPY',
  HAPPY = 'HAPPY',
  SAD = 'SAD',
  VERY_SAD = 'VERY_SAD'
}

export type SurveyConnection = {
   __typename?: 'SurveyConnection',
  pageInfo: PageInfo,
  edges: Array<Maybe<SurveyEdge>>,
  aggregate: AggregateSurvey,
};

export type SurveyCreateInput = {
  name?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  questions?: Maybe<SurveyQuestionCreateManyWithoutSurveyInput>,
  hoodId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyCreateOneWithoutQuestionsInput = {
  create?: Maybe<SurveyCreateWithoutQuestionsInput>,
  connect?: Maybe<SurveyWhereUniqueInput>,
};

export type SurveyCreateWithoutQuestionsInput = {
  name?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  hoodId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyEdge = {
   __typename?: 'SurveyEdge',
  node: Survey,
  cursor: Scalars['String'],
};

export enum SurveyOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  NAME_ASC = 'name_ASC',
  NAME_DESC = 'name_DESC',
  TITLE_ASC = 'title_ASC',
  TITLE_DESC = 'title_DESC',
  DESCRIPTION_ASC = 'description_ASC',
  DESCRIPTION_DESC = 'description_DESC',
  ENABLED_ASC = 'enabled_ASC',
  ENABLED_DESC = 'enabled_DESC',
  ISANONYMOUS_ASC = 'isAnonymous_ASC',
  ISANONYMOUS_DESC = 'isAnonymous_DESC',
  HOODID_ASC = 'hoodId_ASC',
  HOODID_DESC = 'hoodId_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type SurveyPreviousValues = {
   __typename?: 'SurveyPreviousValues',
  id: Scalars['ID'],
  name?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  hoodId?: Maybe<Scalars['String']>,
  createdAt: Scalars['DateTime'],
  updatedAt: Scalars['DateTime'],
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted: Scalars['Int'],
};

export type SurveyQuestion = {
   __typename?: 'SurveyQuestion',
  id: Scalars['ID'],
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  responses?: Maybe<Array<SurveyQuestionResponse>>,
  survey: Survey,
  createdAt: Scalars['DateTime'],
  updatedAt: Scalars['DateTime'],
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted: Scalars['Int'],
  surveyId: Scalars['ID'],
};


export type SurveyQuestionResponsesArgs = {
  where?: Maybe<SurveyQuestionResponseWhereInput>,
  orderBy?: Maybe<SurveyQuestionResponseOrderByInput>,
  skip?: Maybe<Scalars['Int']>,
  after?: Maybe<Scalars['String']>,
  before?: Maybe<Scalars['String']>,
  first?: Maybe<Scalars['Int']>,
  last?: Maybe<Scalars['Int']>
};

export type SurveyQuestionConnection = {
   __typename?: 'SurveyQuestionConnection',
  pageInfo: PageInfo,
  edges: Array<Maybe<SurveyQuestionEdge>>,
  aggregate: AggregateSurveyQuestion,
};

export type SurveyQuestionCreateInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  responses?: Maybe<SurveyQuestionResponseCreateManyWithoutQuestionInput>,
  survey: SurveyCreateOneWithoutQuestionsInput,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionCreateManyWithoutSurveyInput = {
  create?: Maybe<Array<SurveyQuestionCreateWithoutSurveyInput>>,
  connect?: Maybe<Array<SurveyQuestionWhereUniqueInput>>,
};

export type SurveyQuestionCreateOneWithoutResponsesInput = {
  create?: Maybe<SurveyQuestionCreateWithoutResponsesInput>,
  connect?: Maybe<SurveyQuestionWhereUniqueInput>,
};

export type SurveyQuestionCreateWithoutResponsesInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  survey: SurveyCreateOneWithoutQuestionsInput,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionCreateWithoutSurveyInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  responses?: Maybe<SurveyQuestionResponseCreateManyWithoutQuestionInput>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionEdge = {
   __typename?: 'SurveyQuestionEdge',
  node: SurveyQuestion,
  cursor: Scalars['String'],
};

export enum SurveyQuestionOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  TEXT_ASC = 'text_ASC',
  TEXT_DESC = 'text_DESC',
  OPTIONS_ASC = 'options_ASC',
  OPTIONS_DESC = 'options_DESC',
  ADDCOMMENTFIELD_ASC = 'addCommentField_ASC',
  ADDCOMMENTFIELD_DESC = 'addCommentField_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type SurveyQuestionPreviousValues = {
   __typename?: 'SurveyQuestionPreviousValues',
  id: Scalars['ID'],
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  createdAt: Scalars['DateTime'],
  updatedAt: Scalars['DateTime'],
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted: Scalars['Int'],
};

export type SurveyQuestionResponse = {
   __typename?: 'SurveyQuestionResponse',
  id: Scalars['ID'],
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  question: SurveyQuestion,
  responderId?: Maybe<Scalars['String']>,
  createdAt: Scalars['DateTime'],
  updatedAt: Scalars['DateTime'],
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted: Scalars['Int'],
  questionId: Scalars['ID'],
};

export type SurveyQuestionResponseConnection = {
   __typename?: 'SurveyQuestionResponseConnection',
  pageInfo: PageInfo,
  edges: Array<Maybe<SurveyQuestionResponseEdge>>,
  aggregate: AggregateSurveyQuestionResponse,
};

export type SurveyQuestionResponseCreateInput = {
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  question: SurveyQuestionCreateOneWithoutResponsesInput,
  responderId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionResponseCreateManyWithoutQuestionInput = {
  create?: Maybe<Array<SurveyQuestionResponseCreateWithoutQuestionInput>>,
  connect?: Maybe<Array<SurveyQuestionResponseWhereUniqueInput>>,
};

export type SurveyQuestionResponseCreateWithoutQuestionInput = {
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  responderId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionResponseEdge = {
   __typename?: 'SurveyQuestionResponseEdge',
  node: SurveyQuestionResponse,
  cursor: Scalars['String'],
};

export enum SurveyQuestionResponseOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  VALUE_ASC = 'value_ASC',
  VALUE_DESC = 'value_DESC',
  COMMENT_ASC = 'comment_ASC',
  COMMENT_DESC = 'comment_DESC',
  RESPONDERID_ASC = 'responderId_ASC',
  RESPONDERID_DESC = 'responderId_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type SurveyQuestionResponsePreviousValues = {
   __typename?: 'SurveyQuestionResponsePreviousValues',
  id: Scalars['ID'],
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  responderId?: Maybe<Scalars['String']>,
  createdAt: Scalars['DateTime'],
  updatedAt: Scalars['DateTime'],
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted: Scalars['Int'],
};

export type SurveyQuestionResponseScalarWhereInput = {
  id?: Maybe<Scalars['ID']>,
  id_not?: Maybe<Scalars['ID']>,
  id_in?: Maybe<Array<Scalars['ID']>>,
  id_not_in?: Maybe<Array<Scalars['ID']>>,
  id_lt?: Maybe<Scalars['ID']>,
  id_lte?: Maybe<Scalars['ID']>,
  id_gt?: Maybe<Scalars['ID']>,
  id_gte?: Maybe<Scalars['ID']>,
  id_contains?: Maybe<Scalars['ID']>,
  id_not_contains?: Maybe<Scalars['ID']>,
  id_starts_with?: Maybe<Scalars['ID']>,
  id_not_starts_with?: Maybe<Scalars['ID']>,
  id_ends_with?: Maybe<Scalars['ID']>,
  id_not_ends_with?: Maybe<Scalars['ID']>,
  value?: Maybe<SurveyResponses>,
  value_not?: Maybe<SurveyResponses>,
  value_in?: Maybe<Array<SurveyResponses>>,
  value_not_in?: Maybe<Array<SurveyResponses>>,
  comment?: Maybe<Scalars['String']>,
  comment_not?: Maybe<Scalars['String']>,
  comment_in?: Maybe<Array<Scalars['String']>>,
  comment_not_in?: Maybe<Array<Scalars['String']>>,
  comment_lt?: Maybe<Scalars['String']>,
  comment_lte?: Maybe<Scalars['String']>,
  comment_gt?: Maybe<Scalars['String']>,
  comment_gte?: Maybe<Scalars['String']>,
  comment_contains?: Maybe<Scalars['String']>,
  comment_not_contains?: Maybe<Scalars['String']>,
  comment_starts_with?: Maybe<Scalars['String']>,
  comment_not_starts_with?: Maybe<Scalars['String']>,
  comment_ends_with?: Maybe<Scalars['String']>,
  comment_not_ends_with?: Maybe<Scalars['String']>,
  responderId?: Maybe<Scalars['String']>,
  responderId_not?: Maybe<Scalars['String']>,
  responderId_in?: Maybe<Array<Scalars['String']>>,
  responderId_not_in?: Maybe<Array<Scalars['String']>>,
  responderId_lt?: Maybe<Scalars['String']>,
  responderId_lte?: Maybe<Scalars['String']>,
  responderId_gt?: Maybe<Scalars['String']>,
  responderId_gte?: Maybe<Scalars['String']>,
  responderId_contains?: Maybe<Scalars['String']>,
  responderId_not_contains?: Maybe<Scalars['String']>,
  responderId_starts_with?: Maybe<Scalars['String']>,
  responderId_not_starts_with?: Maybe<Scalars['String']>,
  responderId_ends_with?: Maybe<Scalars['String']>,
  responderId_not_ends_with?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['DateTime']>,
  createdAt_not?: Maybe<Scalars['DateTime']>,
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_lt?: Maybe<Scalars['DateTime']>,
  createdAt_lte?: Maybe<Scalars['DateTime']>,
  createdAt_gt?: Maybe<Scalars['DateTime']>,
  createdAt_gte?: Maybe<Scalars['DateTime']>,
  updatedAt?: Maybe<Scalars['DateTime']>,
  updatedAt_not?: Maybe<Scalars['DateTime']>,
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_lt?: Maybe<Scalars['DateTime']>,
  updatedAt_lte?: Maybe<Scalars['DateTime']>,
  updatedAt_gt?: Maybe<Scalars['DateTime']>,
  updatedAt_gte?: Maybe<Scalars['DateTime']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deletedAt_not?: Maybe<Scalars['DateTime']>,
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_lt?: Maybe<Scalars['DateTime']>,
  deletedAt_lte?: Maybe<Scalars['DateTime']>,
  deletedAt_gt?: Maybe<Scalars['DateTime']>,
  deletedAt_gte?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
  deleted_not?: Maybe<Scalars['Int']>,
  deleted_in?: Maybe<Array<Scalars['Int']>>,
  deleted_not_in?: Maybe<Array<Scalars['Int']>>,
  deleted_lt?: Maybe<Scalars['Int']>,
  deleted_lte?: Maybe<Scalars['Int']>,
  deleted_gt?: Maybe<Scalars['Int']>,
  deleted_gte?: Maybe<Scalars['Int']>,
  AND?: Maybe<Array<SurveyQuestionResponseScalarWhereInput>>,
  OR?: Maybe<Array<SurveyQuestionResponseScalarWhereInput>>,
  NOT?: Maybe<Array<SurveyQuestionResponseScalarWhereInput>>,
};

export type SurveyQuestionResponseSubscriptionPayload = {
   __typename?: 'SurveyQuestionResponseSubscriptionPayload',
  mutation: MutationType,
  node?: Maybe<SurveyQuestionResponse>,
  updatedFields?: Maybe<Array<Scalars['String']>>,
  previousValues?: Maybe<SurveyQuestionResponsePreviousValues>,
};

export type SurveyQuestionResponseSubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>,
  updatedFields_contains?: Maybe<Scalars['String']>,
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>,
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>,
  node?: Maybe<SurveyQuestionResponseWhereInput>,
  AND?: Maybe<Array<SurveyQuestionResponseSubscriptionWhereInput>>,
  OR?: Maybe<Array<SurveyQuestionResponseSubscriptionWhereInput>>,
  NOT?: Maybe<Array<SurveyQuestionResponseSubscriptionWhereInput>>,
};

export type SurveyQuestionResponseUpdateInput = {
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  question?: Maybe<SurveyQuestionUpdateOneRequiredWithoutResponsesInput>,
  responderId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionResponseUpdateManyDataInput = {
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  responderId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionResponseUpdateManyMutationInput = {
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  responderId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionResponseUpdateManyWithoutQuestionInput = {
  create?: Maybe<Array<SurveyQuestionResponseCreateWithoutQuestionInput>>,
  delete?: Maybe<Array<SurveyQuestionResponseWhereUniqueInput>>,
  connect?: Maybe<Array<SurveyQuestionResponseWhereUniqueInput>>,
  set?: Maybe<Array<SurveyQuestionResponseWhereUniqueInput>>,
  disconnect?: Maybe<Array<SurveyQuestionResponseWhereUniqueInput>>,
  update?: Maybe<Array<SurveyQuestionResponseUpdateWithWhereUniqueWithoutQuestionInput>>,
  upsert?: Maybe<Array<SurveyQuestionResponseUpsertWithWhereUniqueWithoutQuestionInput>>,
  deleteMany?: Maybe<Array<SurveyQuestionResponseScalarWhereInput>>,
  updateMany?: Maybe<Array<SurveyQuestionResponseUpdateManyWithWhereNestedInput>>,
};

export type SurveyQuestionResponseUpdateManyWithWhereNestedInput = {
  where: SurveyQuestionResponseScalarWhereInput,
  data: SurveyQuestionResponseUpdateManyDataInput,
};

export type SurveyQuestionResponseUpdateWithoutQuestionDataInput = {
  value?: Maybe<SurveyResponses>,
  comment?: Maybe<Scalars['String']>,
  responderId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionResponseUpdateWithWhereUniqueWithoutQuestionInput = {
  where: SurveyQuestionResponseWhereUniqueInput,
  data: SurveyQuestionResponseUpdateWithoutQuestionDataInput,
};

export type SurveyQuestionResponseUpsertWithWhereUniqueWithoutQuestionInput = {
  where: SurveyQuestionResponseWhereUniqueInput,
  update: SurveyQuestionResponseUpdateWithoutQuestionDataInput,
  create: SurveyQuestionResponseCreateWithoutQuestionInput,
};

export type SurveyQuestionResponseWhereInput = {
  id?: Maybe<Scalars['ID']>,
  id_not?: Maybe<Scalars['ID']>,
  id_in?: Maybe<Array<Scalars['ID']>>,
  id_not_in?: Maybe<Array<Scalars['ID']>>,
  id_lt?: Maybe<Scalars['ID']>,
  id_lte?: Maybe<Scalars['ID']>,
  id_gt?: Maybe<Scalars['ID']>,
  id_gte?: Maybe<Scalars['ID']>,
  id_contains?: Maybe<Scalars['ID']>,
  id_not_contains?: Maybe<Scalars['ID']>,
  id_starts_with?: Maybe<Scalars['ID']>,
  id_not_starts_with?: Maybe<Scalars['ID']>,
  id_ends_with?: Maybe<Scalars['ID']>,
  id_not_ends_with?: Maybe<Scalars['ID']>,
  value?: Maybe<SurveyResponses>,
  value_not?: Maybe<SurveyResponses>,
  value_in?: Maybe<Array<SurveyResponses>>,
  value_not_in?: Maybe<Array<SurveyResponses>>,
  comment?: Maybe<Scalars['String']>,
  comment_not?: Maybe<Scalars['String']>,
  comment_in?: Maybe<Array<Scalars['String']>>,
  comment_not_in?: Maybe<Array<Scalars['String']>>,
  comment_lt?: Maybe<Scalars['String']>,
  comment_lte?: Maybe<Scalars['String']>,
  comment_gt?: Maybe<Scalars['String']>,
  comment_gte?: Maybe<Scalars['String']>,
  comment_contains?: Maybe<Scalars['String']>,
  comment_not_contains?: Maybe<Scalars['String']>,
  comment_starts_with?: Maybe<Scalars['String']>,
  comment_not_starts_with?: Maybe<Scalars['String']>,
  comment_ends_with?: Maybe<Scalars['String']>,
  comment_not_ends_with?: Maybe<Scalars['String']>,
  question?: Maybe<SurveyQuestionWhereInput>,
  responderId?: Maybe<Scalars['String']>,
  responderId_not?: Maybe<Scalars['String']>,
  responderId_in?: Maybe<Array<Scalars['String']>>,
  responderId_not_in?: Maybe<Array<Scalars['String']>>,
  responderId_lt?: Maybe<Scalars['String']>,
  responderId_lte?: Maybe<Scalars['String']>,
  responderId_gt?: Maybe<Scalars['String']>,
  responderId_gte?: Maybe<Scalars['String']>,
  responderId_contains?: Maybe<Scalars['String']>,
  responderId_not_contains?: Maybe<Scalars['String']>,
  responderId_starts_with?: Maybe<Scalars['String']>,
  responderId_not_starts_with?: Maybe<Scalars['String']>,
  responderId_ends_with?: Maybe<Scalars['String']>,
  responderId_not_ends_with?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['DateTime']>,
  createdAt_not?: Maybe<Scalars['DateTime']>,
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_lt?: Maybe<Scalars['DateTime']>,
  createdAt_lte?: Maybe<Scalars['DateTime']>,
  createdAt_gt?: Maybe<Scalars['DateTime']>,
  createdAt_gte?: Maybe<Scalars['DateTime']>,
  updatedAt?: Maybe<Scalars['DateTime']>,
  updatedAt_not?: Maybe<Scalars['DateTime']>,
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_lt?: Maybe<Scalars['DateTime']>,
  updatedAt_lte?: Maybe<Scalars['DateTime']>,
  updatedAt_gt?: Maybe<Scalars['DateTime']>,
  updatedAt_gte?: Maybe<Scalars['DateTime']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deletedAt_not?: Maybe<Scalars['DateTime']>,
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_lt?: Maybe<Scalars['DateTime']>,
  deletedAt_lte?: Maybe<Scalars['DateTime']>,
  deletedAt_gt?: Maybe<Scalars['DateTime']>,
  deletedAt_gte?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
  deleted_not?: Maybe<Scalars['Int']>,
  deleted_in?: Maybe<Array<Scalars['Int']>>,
  deleted_not_in?: Maybe<Array<Scalars['Int']>>,
  deleted_lt?: Maybe<Scalars['Int']>,
  deleted_lte?: Maybe<Scalars['Int']>,
  deleted_gt?: Maybe<Scalars['Int']>,
  deleted_gte?: Maybe<Scalars['Int']>,
  AND?: Maybe<Array<SurveyQuestionResponseWhereInput>>,
  OR?: Maybe<Array<SurveyQuestionResponseWhereInput>>,
  NOT?: Maybe<Array<SurveyQuestionResponseWhereInput>>,
};

export type SurveyQuestionResponseWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>,
};

export type SurveyQuestionScalarWhereInput = {
  id?: Maybe<Scalars['ID']>,
  id_not?: Maybe<Scalars['ID']>,
  id_in?: Maybe<Array<Scalars['ID']>>,
  id_not_in?: Maybe<Array<Scalars['ID']>>,
  id_lt?: Maybe<Scalars['ID']>,
  id_lte?: Maybe<Scalars['ID']>,
  id_gt?: Maybe<Scalars['ID']>,
  id_gte?: Maybe<Scalars['ID']>,
  id_contains?: Maybe<Scalars['ID']>,
  id_not_contains?: Maybe<Scalars['ID']>,
  id_starts_with?: Maybe<Scalars['ID']>,
  id_not_starts_with?: Maybe<Scalars['ID']>,
  id_ends_with?: Maybe<Scalars['ID']>,
  id_not_ends_with?: Maybe<Scalars['ID']>,
  text?: Maybe<Scalars['String']>,
  text_not?: Maybe<Scalars['String']>,
  text_in?: Maybe<Array<Scalars['String']>>,
  text_not_in?: Maybe<Array<Scalars['String']>>,
  text_lt?: Maybe<Scalars['String']>,
  text_lte?: Maybe<Scalars['String']>,
  text_gt?: Maybe<Scalars['String']>,
  text_gte?: Maybe<Scalars['String']>,
  text_contains?: Maybe<Scalars['String']>,
  text_not_contains?: Maybe<Scalars['String']>,
  text_starts_with?: Maybe<Scalars['String']>,
  text_not_starts_with?: Maybe<Scalars['String']>,
  text_ends_with?: Maybe<Scalars['String']>,
  text_not_ends_with?: Maybe<Scalars['String']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  addCommentField_not?: Maybe<Scalars['Boolean']>,
  createdAt?: Maybe<Scalars['DateTime']>,
  createdAt_not?: Maybe<Scalars['DateTime']>,
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_lt?: Maybe<Scalars['DateTime']>,
  createdAt_lte?: Maybe<Scalars['DateTime']>,
  createdAt_gt?: Maybe<Scalars['DateTime']>,
  createdAt_gte?: Maybe<Scalars['DateTime']>,
  updatedAt?: Maybe<Scalars['DateTime']>,
  updatedAt_not?: Maybe<Scalars['DateTime']>,
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_lt?: Maybe<Scalars['DateTime']>,
  updatedAt_lte?: Maybe<Scalars['DateTime']>,
  updatedAt_gt?: Maybe<Scalars['DateTime']>,
  updatedAt_gte?: Maybe<Scalars['DateTime']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deletedAt_not?: Maybe<Scalars['DateTime']>,
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_lt?: Maybe<Scalars['DateTime']>,
  deletedAt_lte?: Maybe<Scalars['DateTime']>,
  deletedAt_gt?: Maybe<Scalars['DateTime']>,
  deletedAt_gte?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
  deleted_not?: Maybe<Scalars['Int']>,
  deleted_in?: Maybe<Array<Scalars['Int']>>,
  deleted_not_in?: Maybe<Array<Scalars['Int']>>,
  deleted_lt?: Maybe<Scalars['Int']>,
  deleted_lte?: Maybe<Scalars['Int']>,
  deleted_gt?: Maybe<Scalars['Int']>,
  deleted_gte?: Maybe<Scalars['Int']>,
  AND?: Maybe<Array<SurveyQuestionScalarWhereInput>>,
  OR?: Maybe<Array<SurveyQuestionScalarWhereInput>>,
  NOT?: Maybe<Array<SurveyQuestionScalarWhereInput>>,
};

export type SurveyQuestionSubscriptionPayload = {
   __typename?: 'SurveyQuestionSubscriptionPayload',
  mutation: MutationType,
  node?: Maybe<SurveyQuestion>,
  updatedFields?: Maybe<Array<Scalars['String']>>,
  previousValues?: Maybe<SurveyQuestionPreviousValues>,
};

export type SurveyQuestionSubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>,
  updatedFields_contains?: Maybe<Scalars['String']>,
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>,
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>,
  node?: Maybe<SurveyQuestionWhereInput>,
  AND?: Maybe<Array<SurveyQuestionSubscriptionWhereInput>>,
  OR?: Maybe<Array<SurveyQuestionSubscriptionWhereInput>>,
  NOT?: Maybe<Array<SurveyQuestionSubscriptionWhereInput>>,
};

export type SurveyQuestionUpdateInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  responses?: Maybe<SurveyQuestionResponseUpdateManyWithoutQuestionInput>,
  survey?: Maybe<SurveyUpdateOneRequiredWithoutQuestionsInput>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionUpdateManyDataInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionUpdateManyMutationInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionUpdateManyWithoutSurveyInput = {
  create?: Maybe<Array<SurveyQuestionCreateWithoutSurveyInput>>,
  delete?: Maybe<Array<SurveyQuestionWhereUniqueInput>>,
  connect?: Maybe<Array<SurveyQuestionWhereUniqueInput>>,
  set?: Maybe<Array<SurveyQuestionWhereUniqueInput>>,
  disconnect?: Maybe<Array<SurveyQuestionWhereUniqueInput>>,
  update?: Maybe<Array<SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput>>,
  upsert?: Maybe<Array<SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput>>,
  deleteMany?: Maybe<Array<SurveyQuestionScalarWhereInput>>,
  updateMany?: Maybe<Array<SurveyQuestionUpdateManyWithWhereNestedInput>>,
};

export type SurveyQuestionUpdateManyWithWhereNestedInput = {
  where: SurveyQuestionScalarWhereInput,
  data: SurveyQuestionUpdateManyDataInput,
};

export type SurveyQuestionUpdateOneRequiredWithoutResponsesInput = {
  create?: Maybe<SurveyQuestionCreateWithoutResponsesInput>,
  update?: Maybe<SurveyQuestionUpdateWithoutResponsesDataInput>,
  upsert?: Maybe<SurveyQuestionUpsertWithoutResponsesInput>,
  connect?: Maybe<SurveyQuestionWhereUniqueInput>,
};

export type SurveyQuestionUpdateWithoutResponsesDataInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  survey?: Maybe<SurveyUpdateOneRequiredWithoutQuestionsInput>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionUpdateWithoutSurveyDataInput = {
  text?: Maybe<Scalars['String']>,
  options?: Maybe<Scalars['Json']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  responses?: Maybe<SurveyQuestionResponseUpdateManyWithoutQuestionInput>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput = {
  where: SurveyQuestionWhereUniqueInput,
  data: SurveyQuestionUpdateWithoutSurveyDataInput,
};

export type SurveyQuestionUpsertWithoutResponsesInput = {
  update: SurveyQuestionUpdateWithoutResponsesDataInput,
  create: SurveyQuestionCreateWithoutResponsesInput,
};

export type SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput = {
  where: SurveyQuestionWhereUniqueInput,
  update: SurveyQuestionUpdateWithoutSurveyDataInput,
  create: SurveyQuestionCreateWithoutSurveyInput,
};

export type SurveyQuestionWhereInput = {
  id?: Maybe<Scalars['ID']>,
  id_not?: Maybe<Scalars['ID']>,
  id_in?: Maybe<Array<Scalars['ID']>>,
  id_not_in?: Maybe<Array<Scalars['ID']>>,
  id_lt?: Maybe<Scalars['ID']>,
  id_lte?: Maybe<Scalars['ID']>,
  id_gt?: Maybe<Scalars['ID']>,
  id_gte?: Maybe<Scalars['ID']>,
  id_contains?: Maybe<Scalars['ID']>,
  id_not_contains?: Maybe<Scalars['ID']>,
  id_starts_with?: Maybe<Scalars['ID']>,
  id_not_starts_with?: Maybe<Scalars['ID']>,
  id_ends_with?: Maybe<Scalars['ID']>,
  id_not_ends_with?: Maybe<Scalars['ID']>,
  text?: Maybe<Scalars['String']>,
  text_not?: Maybe<Scalars['String']>,
  text_in?: Maybe<Array<Scalars['String']>>,
  text_not_in?: Maybe<Array<Scalars['String']>>,
  text_lt?: Maybe<Scalars['String']>,
  text_lte?: Maybe<Scalars['String']>,
  text_gt?: Maybe<Scalars['String']>,
  text_gte?: Maybe<Scalars['String']>,
  text_contains?: Maybe<Scalars['String']>,
  text_not_contains?: Maybe<Scalars['String']>,
  text_starts_with?: Maybe<Scalars['String']>,
  text_not_starts_with?: Maybe<Scalars['String']>,
  text_ends_with?: Maybe<Scalars['String']>,
  text_not_ends_with?: Maybe<Scalars['String']>,
  addCommentField?: Maybe<Scalars['Boolean']>,
  addCommentField_not?: Maybe<Scalars['Boolean']>,
  responses_every?: Maybe<SurveyQuestionResponseWhereInput>,
  responses_some?: Maybe<SurveyQuestionResponseWhereInput>,
  responses_none?: Maybe<SurveyQuestionResponseWhereInput>,
  survey?: Maybe<SurveyWhereInput>,
  createdAt?: Maybe<Scalars['DateTime']>,
  createdAt_not?: Maybe<Scalars['DateTime']>,
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_lt?: Maybe<Scalars['DateTime']>,
  createdAt_lte?: Maybe<Scalars['DateTime']>,
  createdAt_gt?: Maybe<Scalars['DateTime']>,
  createdAt_gte?: Maybe<Scalars['DateTime']>,
  updatedAt?: Maybe<Scalars['DateTime']>,
  updatedAt_not?: Maybe<Scalars['DateTime']>,
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_lt?: Maybe<Scalars['DateTime']>,
  updatedAt_lte?: Maybe<Scalars['DateTime']>,
  updatedAt_gt?: Maybe<Scalars['DateTime']>,
  updatedAt_gte?: Maybe<Scalars['DateTime']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deletedAt_not?: Maybe<Scalars['DateTime']>,
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_lt?: Maybe<Scalars['DateTime']>,
  deletedAt_lte?: Maybe<Scalars['DateTime']>,
  deletedAt_gt?: Maybe<Scalars['DateTime']>,
  deletedAt_gte?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
  deleted_not?: Maybe<Scalars['Int']>,
  deleted_in?: Maybe<Array<Scalars['Int']>>,
  deleted_not_in?: Maybe<Array<Scalars['Int']>>,
  deleted_lt?: Maybe<Scalars['Int']>,
  deleted_lte?: Maybe<Scalars['Int']>,
  deleted_gt?: Maybe<Scalars['Int']>,
  deleted_gte?: Maybe<Scalars['Int']>,
  AND?: Maybe<Array<SurveyQuestionWhereInput>>,
  OR?: Maybe<Array<SurveyQuestionWhereInput>>,
  NOT?: Maybe<Array<SurveyQuestionWhereInput>>,
};

export type SurveyQuestionWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>,
};

export type SurveySubscriptionPayload = {
   __typename?: 'SurveySubscriptionPayload',
  mutation: MutationType,
  node?: Maybe<Survey>,
  updatedFields?: Maybe<Array<Scalars['String']>>,
  previousValues?: Maybe<SurveyPreviousValues>,
};

export type SurveySubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>,
  updatedFields_contains?: Maybe<Scalars['String']>,
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>,
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>,
  node?: Maybe<SurveyWhereInput>,
  AND?: Maybe<Array<SurveySubscriptionWhereInput>>,
  OR?: Maybe<Array<SurveySubscriptionWhereInput>>,
  NOT?: Maybe<Array<SurveySubscriptionWhereInput>>,
};

export type SurveyUpdateInput = {
  name?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  questions?: Maybe<SurveyQuestionUpdateManyWithoutSurveyInput>,
  hoodId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyUpdateManyMutationInput = {
  name?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  hoodId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyUpdateOneRequiredWithoutQuestionsInput = {
  create?: Maybe<SurveyCreateWithoutQuestionsInput>,
  update?: Maybe<SurveyUpdateWithoutQuestionsDataInput>,
  upsert?: Maybe<SurveyUpsertWithoutQuestionsInput>,
  connect?: Maybe<SurveyWhereUniqueInput>,
};

export type SurveyUpdateWithoutQuestionsDataInput = {
  name?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  hoodId?: Maybe<Scalars['String']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
};

export type SurveyUpsertWithoutQuestionsInput = {
  update: SurveyUpdateWithoutQuestionsDataInput,
  create: SurveyCreateWithoutQuestionsInput,
};

export type SurveyWhereInput = {
  id?: Maybe<Scalars['ID']>,
  id_not?: Maybe<Scalars['ID']>,
  id_in?: Maybe<Array<Scalars['ID']>>,
  id_not_in?: Maybe<Array<Scalars['ID']>>,
  id_lt?: Maybe<Scalars['ID']>,
  id_lte?: Maybe<Scalars['ID']>,
  id_gt?: Maybe<Scalars['ID']>,
  id_gte?: Maybe<Scalars['ID']>,
  id_contains?: Maybe<Scalars['ID']>,
  id_not_contains?: Maybe<Scalars['ID']>,
  id_starts_with?: Maybe<Scalars['ID']>,
  id_not_starts_with?: Maybe<Scalars['ID']>,
  id_ends_with?: Maybe<Scalars['ID']>,
  id_not_ends_with?: Maybe<Scalars['ID']>,
  name?: Maybe<Scalars['String']>,
  name_not?: Maybe<Scalars['String']>,
  name_in?: Maybe<Array<Scalars['String']>>,
  name_not_in?: Maybe<Array<Scalars['String']>>,
  name_lt?: Maybe<Scalars['String']>,
  name_lte?: Maybe<Scalars['String']>,
  name_gt?: Maybe<Scalars['String']>,
  name_gte?: Maybe<Scalars['String']>,
  name_contains?: Maybe<Scalars['String']>,
  name_not_contains?: Maybe<Scalars['String']>,
  name_starts_with?: Maybe<Scalars['String']>,
  name_not_starts_with?: Maybe<Scalars['String']>,
  name_ends_with?: Maybe<Scalars['String']>,
  name_not_ends_with?: Maybe<Scalars['String']>,
  title?: Maybe<Scalars['String']>,
  title_not?: Maybe<Scalars['String']>,
  title_in?: Maybe<Array<Scalars['String']>>,
  title_not_in?: Maybe<Array<Scalars['String']>>,
  title_lt?: Maybe<Scalars['String']>,
  title_lte?: Maybe<Scalars['String']>,
  title_gt?: Maybe<Scalars['String']>,
  title_gte?: Maybe<Scalars['String']>,
  title_contains?: Maybe<Scalars['String']>,
  title_not_contains?: Maybe<Scalars['String']>,
  title_starts_with?: Maybe<Scalars['String']>,
  title_not_starts_with?: Maybe<Scalars['String']>,
  title_ends_with?: Maybe<Scalars['String']>,
  title_not_ends_with?: Maybe<Scalars['String']>,
  description?: Maybe<Scalars['String']>,
  description_not?: Maybe<Scalars['String']>,
  description_in?: Maybe<Array<Scalars['String']>>,
  description_not_in?: Maybe<Array<Scalars['String']>>,
  description_lt?: Maybe<Scalars['String']>,
  description_lte?: Maybe<Scalars['String']>,
  description_gt?: Maybe<Scalars['String']>,
  description_gte?: Maybe<Scalars['String']>,
  description_contains?: Maybe<Scalars['String']>,
  description_not_contains?: Maybe<Scalars['String']>,
  description_starts_with?: Maybe<Scalars['String']>,
  description_not_starts_with?: Maybe<Scalars['String']>,
  description_ends_with?: Maybe<Scalars['String']>,
  description_not_ends_with?: Maybe<Scalars['String']>,
  enabled?: Maybe<Scalars['Boolean']>,
  enabled_not?: Maybe<Scalars['Boolean']>,
  isAnonymous?: Maybe<Scalars['Boolean']>,
  isAnonymous_not?: Maybe<Scalars['Boolean']>,
  questions_every?: Maybe<SurveyQuestionWhereInput>,
  questions_some?: Maybe<SurveyQuestionWhereInput>,
  questions_none?: Maybe<SurveyQuestionWhereInput>,
  hoodId?: Maybe<Scalars['String']>,
  hoodId_not?: Maybe<Scalars['String']>,
  hoodId_in?: Maybe<Array<Scalars['String']>>,
  hoodId_not_in?: Maybe<Array<Scalars['String']>>,
  hoodId_lt?: Maybe<Scalars['String']>,
  hoodId_lte?: Maybe<Scalars['String']>,
  hoodId_gt?: Maybe<Scalars['String']>,
  hoodId_gte?: Maybe<Scalars['String']>,
  hoodId_contains?: Maybe<Scalars['String']>,
  hoodId_not_contains?: Maybe<Scalars['String']>,
  hoodId_starts_with?: Maybe<Scalars['String']>,
  hoodId_not_starts_with?: Maybe<Scalars['String']>,
  hoodId_ends_with?: Maybe<Scalars['String']>,
  hoodId_not_ends_with?: Maybe<Scalars['String']>,
  createdAt?: Maybe<Scalars['DateTime']>,
  createdAt_not?: Maybe<Scalars['DateTime']>,
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  createdAt_lt?: Maybe<Scalars['DateTime']>,
  createdAt_lte?: Maybe<Scalars['DateTime']>,
  createdAt_gt?: Maybe<Scalars['DateTime']>,
  createdAt_gte?: Maybe<Scalars['DateTime']>,
  updatedAt?: Maybe<Scalars['DateTime']>,
  updatedAt_not?: Maybe<Scalars['DateTime']>,
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  updatedAt_lt?: Maybe<Scalars['DateTime']>,
  updatedAt_lte?: Maybe<Scalars['DateTime']>,
  updatedAt_gt?: Maybe<Scalars['DateTime']>,
  updatedAt_gte?: Maybe<Scalars['DateTime']>,
  deletedAt?: Maybe<Scalars['DateTime']>,
  deletedAt_not?: Maybe<Scalars['DateTime']>,
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>,
  deletedAt_lt?: Maybe<Scalars['DateTime']>,
  deletedAt_lte?: Maybe<Scalars['DateTime']>,
  deletedAt_gt?: Maybe<Scalars['DateTime']>,
  deletedAt_gte?: Maybe<Scalars['DateTime']>,
  deleted?: Maybe<Scalars['Int']>,
  deleted_not?: Maybe<Scalars['Int']>,
  deleted_in?: Maybe<Array<Scalars['Int']>>,
  deleted_not_in?: Maybe<Array<Scalars['Int']>>,
  deleted_lt?: Maybe<Scalars['Int']>,
  deleted_lte?: Maybe<Scalars['Int']>,
  deleted_gt?: Maybe<Scalars['Int']>,
  deleted_gte?: Maybe<Scalars['Int']>,
  AND?: Maybe<Array<SurveyWhereInput>>,
  OR?: Maybe<Array<SurveyWhereInput>>,
  NOT?: Maybe<Array<SurveyWhereInput>>,
};

export type SurveyWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>,
  name?: Maybe<Scalars['String']>,
};
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 7`] = `
"export const whitelistSchema = \`type Query {
  survey(where: SurveyWhereUniqueInput!): Survey
}

type Survey {
  id: ID!
  name: String
  title: String
  description: String
  enabled: Boolean
  isAnonymous: Boolean
  questions(where: SurveyQuestionWhereInput, orderBy: SurveyQuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SurveyQuestion!]
  hoodId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input SurveyWhereUniqueInput {
  id: ID
  name: String
}

type SurveyQuestion {
  id: ID!
  text: String
  options: Json
  addCommentField: Boolean
  responses(where: SurveyQuestionResponseWhereInput, orderBy: SurveyQuestionResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SurveyQuestionResponse!]
  survey: Survey!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input SurveyQuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  addCommentField: Boolean
  addCommentField_not: Boolean
  responses_every: SurveyQuestionResponseWhereInput
  responses_some: SurveyQuestionResponseWhereInput
  responses_none: SurveyQuestionResponseWhereInput
  survey: SurveyWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyQuestionWhereInput!]
  OR: [SurveyQuestionWhereInput!]
  NOT: [SurveyQuestionWhereInput!]
}

enum SurveyQuestionOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  options_ASC
  options_DESC
  addCommentField_ASC
  addCommentField_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

scalar DateTime

scalar Json

type SurveyQuestionResponse {
  id: ID!
  value: SURVEY_RESPONSES
  comment: String
  question: SurveyQuestion!
  responderId: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input SurveyQuestionResponseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: SURVEY_RESPONSES
  value_not: SURVEY_RESPONSES
  value_in: [SURVEY_RESPONSES!]
  value_not_in: [SURVEY_RESPONSES!]
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  question: SurveyQuestionWhereInput
  responderId: String
  responderId_not: String
  responderId_in: [String!]
  responderId_not_in: [String!]
  responderId_lt: String
  responderId_lte: String
  responderId_gt: String
  responderId_gte: String
  responderId_contains: String
  responderId_not_contains: String
  responderId_starts_with: String
  responderId_not_starts_with: String
  responderId_ends_with: String
  responderId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyQuestionResponseWhereInput!]
  OR: [SurveyQuestionResponseWhereInput!]
  NOT: [SurveyQuestionResponseWhereInput!]
}

enum SurveyQuestionResponseOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  comment_ASC
  comment_DESC
  responderId_ASC
  responderId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

input SurveyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  enabled: Boolean
  enabled_not: Boolean
  isAnonymous: Boolean
  isAnonymous_not: Boolean
  questions_every: SurveyQuestionWhereInput
  questions_some: SurveyQuestionWhereInput
  questions_none: SurveyQuestionWhereInput
  hoodId: String
  hoodId_not: String
  hoodId_in: [String!]
  hoodId_not_in: [String!]
  hoodId_lt: String
  hoodId_lte: String
  hoodId_gt: String
  hoodId_gte: String
  hoodId_contains: String
  hoodId_not_contains: String
  hoodId_starts_with: String
  hoodId_not_starts_with: String
  hoodId_ends_with: String
  hoodId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [SurveyWhereInput!]
  OR: [SurveyWhereInput!]
  NOT: [SurveyWhereInput!]
}

enum SURVEY_RESPONSES {
  VERY_HAPPY
  HAPPY
  SAD
  VERY_SAD
}
\`;
"
`;
