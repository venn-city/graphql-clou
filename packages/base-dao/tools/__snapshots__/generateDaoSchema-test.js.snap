// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateDaoSchema generate files should be match to snapshots 1`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';
import DataLoader from 'dataloader';

export default class GovernmentDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'government',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  government(context: any, where: openCrudSchema.QueryGovernmentArgs['where']): Promise<openCrudSchema.Query['government']> {
    return this.entityDAO.government(context, where);
  }

  governmentById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['government']> {
    return this.entityDAO.governmentById(context, id);
  }

  governments(context: any, args: openCrudSchema.QueryGovernmentsArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['governments']> {
    return this.entityDAO.governments(context, args);
  }

  governmentsByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['governments']> {
    return this.entityDAO.governmentsByIds(context, ids);
  }

  createGovernment(context: any, data: openCrudSchema.MutationCreateGovernmentArgs['data']): Promise<openCrudSchema.Mutation['createGovernment']> {
    return this.entityDAO.createGovernment(context, data);
  }

  updateGovernment(context: any, args: openCrudSchema.MutationUpdateGovernmentArgs): Promise<openCrudSchema.Mutation['updateGovernment']> {
    return this.entityDAO.updateGovernment(context, args);
  }

  updateManyGovernments(context: any, args: openCrudSchema.MutationUpdateManyGovernmentsArgs): Promise<openCrudSchema.Mutation['updateManyGovernments']> {
    return this.entityDAO.updateManyGovernments(context, args);
  }

  deleteGovernment(context: any, where: openCrudSchema.MutationDeleteGovernmentArgs['where']): Promise<openCrudSchema.Mutation['deleteGovernment']> {
    return this.entityDAO.deleteGovernment(context, where);
  }

  deleteManyGovernments(context: any, where: openCrudSchema.MutationDeleteManyGovernmentsArgs['where']): Promise<openCrudSchema.Mutation['deleteManyGovernments']> {
    return this.entityDAO.deleteManyGovernments(context, where);
  }

  governmentsConnection(parent: any, args: openCrudSchema.QueryGovernmentsConnectionArgs, context: any): Promise<openCrudSchema.Query['governmentsConnection']> {
    return this.entityDAO.governmentsConnection(parent, args, context);
  }

  async getRelatedEntityId(originalEntityId: string, relationEntityName: string, context:any): Promise<string | null> {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntity<T>(originalEntityId: string, relationEntityName: string, context:any): Promise<T | null> {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntityIds(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<string[]> {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntities<T>(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<T[]> {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntitiesByFetchFunction(context:any, fetchFunction:any): Promise<any> {
    return this.entityDAO.getRelatedEntitiesByFetchFunction(context, fetchFunction);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }

  async loadEntity(entityId: string): Promise<any> {
    return this.entityDAO.loadEntity(entityId);
  }

  storeForLoading(entityId: string, entity: any): DataLoader<unknown, unknown> {
    return this.entityDAO.storeForLoading(entityId, entity);
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 2`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';
import DataLoader from 'dataloader';

export default class LobbyistDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'lobbyist',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  lobbyist(context: any, where: openCrudSchema.QueryLobbyistArgs['where']): Promise<openCrudSchema.Query['lobbyist']> {
    return this.entityDAO.lobbyist(context, where);
  }

  lobbyistById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['lobbyist']> {
    return this.entityDAO.lobbyistById(context, id);
  }

  lobbyists(context: any, args: openCrudSchema.QueryLobbyistsArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['lobbyists']> {
    return this.entityDAO.lobbyists(context, args);
  }

  lobbyistsByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['lobbyists']> {
    return this.entityDAO.lobbyistsByIds(context, ids);
  }

  createLobbyist(context: any, data: openCrudSchema.MutationCreateLobbyistArgs['data']): Promise<openCrudSchema.Mutation['createLobbyist']> {
    return this.entityDAO.createLobbyist(context, data);
  }

  updateLobbyist(context: any, args: openCrudSchema.MutationUpdateLobbyistArgs): Promise<openCrudSchema.Mutation['updateLobbyist']> {
    return this.entityDAO.updateLobbyist(context, args);
  }

  updateManyLobbyists(context: any, args: openCrudSchema.MutationUpdateManyLobbyistsArgs): Promise<openCrudSchema.Mutation['updateManyLobbyists']> {
    return this.entityDAO.updateManyLobbyists(context, args);
  }

  deleteLobbyist(context: any, where: openCrudSchema.MutationDeleteLobbyistArgs['where']): Promise<openCrudSchema.Mutation['deleteLobbyist']> {
    return this.entityDAO.deleteLobbyist(context, where);
  }

  deleteManyLobbyists(context: any, where: openCrudSchema.MutationDeleteManyLobbyistsArgs['where']): Promise<openCrudSchema.Mutation['deleteManyLobbyists']> {
    return this.entityDAO.deleteManyLobbyists(context, where);
  }

  lobbyistsConnection(parent: any, args: openCrudSchema.QueryLobbyistsConnectionArgs, context: any): Promise<openCrudSchema.Query['lobbyistsConnection']> {
    return this.entityDAO.lobbyistsConnection(parent, args, context);
  }

  async getRelatedEntityId(originalEntityId: string, relationEntityName: string, context:any): Promise<string | null> {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntity<T>(originalEntityId: string, relationEntityName: string, context:any): Promise<T | null> {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntityIds(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<string[]> {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntities<T>(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<T[]> {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntitiesByFetchFunction(context:any, fetchFunction:any): Promise<any> {
    return this.entityDAO.getRelatedEntitiesByFetchFunction(context, fetchFunction);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }

  async loadEntity(entityId: string): Promise<any> {
    return this.entityDAO.loadEntity(entityId);
  }

  storeForLoading(entityId: string, entity: any): DataLoader<unknown, unknown> {
    return this.entityDAO.storeForLoading(entityId, entity);
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 3`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';
import DataLoader from 'dataloader';

export default class MinisterDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'minister',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  minister(context: any, where: openCrudSchema.QueryMinisterArgs['where']): Promise<openCrudSchema.Query['minister']> {
    return this.entityDAO.minister(context, where);
  }

  ministerById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['minister']> {
    return this.entityDAO.ministerById(context, id);
  }

  ministers(context: any, args: openCrudSchema.QueryMinistersArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['ministers']> {
    return this.entityDAO.ministers(context, args);
  }

  ministersByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['ministers']> {
    return this.entityDAO.ministersByIds(context, ids);
  }

  createMinister(context: any, data: openCrudSchema.MutationCreateMinisterArgs['data']): Promise<openCrudSchema.Mutation['createMinister']> {
    return this.entityDAO.createMinister(context, data);
  }

  updateMinister(context: any, args: openCrudSchema.MutationUpdateMinisterArgs): Promise<openCrudSchema.Mutation['updateMinister']> {
    return this.entityDAO.updateMinister(context, args);
  }

  updateManyMinisters(context: any, args: openCrudSchema.MutationUpdateManyMinistersArgs): Promise<openCrudSchema.Mutation['updateManyMinisters']> {
    return this.entityDAO.updateManyMinisters(context, args);
  }

  deleteMinister(context: any, where: openCrudSchema.MutationDeleteMinisterArgs['where']): Promise<openCrudSchema.Mutation['deleteMinister']> {
    return this.entityDAO.deleteMinister(context, where);
  }

  deleteManyMinisters(context: any, where: openCrudSchema.MutationDeleteManyMinistersArgs['where']): Promise<openCrudSchema.Mutation['deleteManyMinisters']> {
    return this.entityDAO.deleteManyMinisters(context, where);
  }

  ministersConnection(parent: any, args: openCrudSchema.QueryMinistersConnectionArgs, context: any): Promise<openCrudSchema.Query['ministersConnection']> {
    return this.entityDAO.ministersConnection(parent, args, context);
  }

  async getRelatedEntityId(originalEntityId: string, relationEntityName: string, context:any): Promise<string | null> {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntity<T>(originalEntityId: string, relationEntityName: string, context:any): Promise<T | null> {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntityIds(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<string[]> {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntities<T>(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<T[]> {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntitiesByFetchFunction(context:any, fetchFunction:any): Promise<any> {
    return this.entityDAO.getRelatedEntitiesByFetchFunction(context, fetchFunction);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }

  async loadEntity(entityId: string): Promise<any> {
    return this.entityDAO.loadEntity(entityId);
  }

  storeForLoading(entityId: string, entity: any): DataLoader<unknown, unknown> {
    return this.entityDAO.storeForLoading(entityId, entity);
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 4`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';
import DataLoader from 'dataloader';

export default class MinistryDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'ministry',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  ministry(context: any, where: openCrudSchema.QueryMinistryArgs['where']): Promise<openCrudSchema.Query['ministry']> {
    return this.entityDAO.ministry(context, where);
  }

  ministryById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['ministry']> {
    return this.entityDAO.ministryById(context, id);
  }

  ministries(context: any, args: openCrudSchema.QueryMinistriesArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['ministries']> {
    return this.entityDAO.ministries(context, args);
  }

  ministriesByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['ministries']> {
    return this.entityDAO.ministriesByIds(context, ids);
  }

  createMinistry(context: any, data: openCrudSchema.MutationCreateMinistryArgs['data']): Promise<openCrudSchema.Mutation['createMinistry']> {
    return this.entityDAO.createMinistry(context, data);
  }

  updateMinistry(context: any, args: openCrudSchema.MutationUpdateMinistryArgs): Promise<openCrudSchema.Mutation['updateMinistry']> {
    return this.entityDAO.updateMinistry(context, args);
  }

  updateManyMinistries(context: any, args: openCrudSchema.MutationUpdateManyMinistriesArgs): Promise<openCrudSchema.Mutation['updateManyMinistries']> {
    return this.entityDAO.updateManyMinistries(context, args);
  }

  deleteMinistry(context: any, where: openCrudSchema.MutationDeleteMinistryArgs['where']): Promise<openCrudSchema.Mutation['deleteMinistry']> {
    return this.entityDAO.deleteMinistry(context, where);
  }

  deleteManyMinistries(context: any, where: openCrudSchema.MutationDeleteManyMinistriesArgs['where']): Promise<openCrudSchema.Mutation['deleteManyMinistries']> {
    return this.entityDAO.deleteManyMinistries(context, where);
  }

  ministriesConnection(parent: any, args: openCrudSchema.QueryMinistriesConnectionArgs, context: any): Promise<openCrudSchema.Query['ministriesConnection']> {
    return this.entityDAO.ministriesConnection(parent, args, context);
  }

  async getRelatedEntityId(originalEntityId: string, relationEntityName: string, context:any): Promise<string | null> {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntity<T>(originalEntityId: string, relationEntityName: string, context:any): Promise<T | null> {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntityIds(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<string[]> {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntities<T>(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<T[]> {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntitiesByFetchFunction(context:any, fetchFunction:any): Promise<any> {
    return this.entityDAO.getRelatedEntitiesByFetchFunction(context, fetchFunction);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }

  async loadEntity(entityId: string): Promise<any> {
    return this.entityDAO.loadEntity(entityId);
  }

  storeForLoading(entityId: string, entity: any): DataLoader<unknown, unknown> {
    return this.entityDAO.storeForLoading(entityId, entity);
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 5`] = `
"// @ts-ignore
import { createEntityDAO } from '@venncity/base-dao';
import * as openCrudSchema from './openCrudSchema';
import DataLoader from 'dataloader';

export default class VoteDAO {
  private readonly entityDAO: any;

  constructor({ hooks, daoAuth, publishCrudEvent }: { hooks: any, daoAuth: any, publishCrudEvent: any }) {
    this.entityDAO = createEntityDAO({
      entityName: 'vote',
      hooks,
      daoAuth,
      publishCrudEvent
    });
  }

  vote(context: any, where: openCrudSchema.QueryVoteArgs['where']): Promise<openCrudSchema.Query['vote']> {
    return this.entityDAO.vote(context, where);
  }

  voteById(context: any, id: openCrudSchema.Scalars['ID']): Promise<openCrudSchema.Query['vote']> {
    return this.entityDAO.voteById(context, id);
  }

  votes(context: any, args: openCrudSchema.QueryVotesArgs & { skipPagination?: boolean }): Promise<openCrudSchema.Query['votes']> {
    return this.entityDAO.votes(context, args);
  }

  votesByIds(context: any, ids: openCrudSchema.Scalars['ID'][]): Promise<openCrudSchema.Query['votes']> {
    return this.entityDAO.votesByIds(context, ids);
  }

  createVote(context: any, data: openCrudSchema.MutationCreateVoteArgs['data']): Promise<openCrudSchema.Mutation['createVote']> {
    return this.entityDAO.createVote(context, data);
  }

  updateVote(context: any, args: openCrudSchema.MutationUpdateVoteArgs): Promise<openCrudSchema.Mutation['updateVote']> {
    return this.entityDAO.updateVote(context, args);
  }

  updateManyVotes(context: any, args: openCrudSchema.MutationUpdateManyVotesArgs): Promise<openCrudSchema.Mutation['updateManyVotes']> {
    return this.entityDAO.updateManyVotes(context, args);
  }

  deleteVote(context: any, where: openCrudSchema.MutationDeleteVoteArgs['where']): Promise<openCrudSchema.Mutation['deleteVote']> {
    return this.entityDAO.deleteVote(context, where);
  }

  deleteManyVotes(context: any, where: openCrudSchema.MutationDeleteManyVotesArgs['where']): Promise<openCrudSchema.Mutation['deleteManyVotes']> {
    return this.entityDAO.deleteManyVotes(context, where);
  }

  votesConnection(parent: any, args: openCrudSchema.QueryVotesConnectionArgs, context: any): Promise<openCrudSchema.Query['votesConnection']> {
    return this.entityDAO.votesConnection(parent, args, context);
  }

  async getRelatedEntityId(originalEntityId: string, relationEntityName: string, context:any): Promise<string | null> {
    return this.entityDAO.getRelatedEntityId(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntity<T>(originalEntityId: string, relationEntityName: string, context:any): Promise<T | null> {
    return this.entityDAO.getRelatedEntity(originalEntityId, relationEntityName, context);
  }

  async getRelatedEntityIds(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<string[]> {
    return this.entityDAO.getRelatedEntityIds(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntities<T>(originalEntityId: string, relationEntityName: string, context:any, args?: any): Promise<T[]> {
    return this.entityDAO.getRelatedEntities(originalEntityId, relationEntityName, context, args);
  }

  async getRelatedEntitiesByFetchFunction(context:any, fetchFunction:any): Promise<any> {
    return this.entityDAO.getRelatedEntitiesByFetchFunction(context, fetchFunction);
  }

  getHooks(): any {
    return this.entityDAO.getHooks();
  }

  async loadEntity(entityId: string): Promise<any> {
    return this.entityDAO.loadEntity(entityId);
  }

  storeForLoading(entityId: string, entity: any): DataLoader<unknown, unknown> {
    return this.entityDAO.storeForLoading(entityId, entity);
  }
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 6`] = `
"export * from './openCrudSchema';
export * from './whiteListOpenCrudSchema';
export { default as MinistryDAO } from './MinistryDAO';
export { default as MinisterDAO } from './MinisterDAO';
export { default as GovernmentDAO } from './GovernmentDAO';
export { default as VoteDAO } from './VoteDAO';
export { default as LobbyistDAO } from './LobbyistDAO';
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 7`] = `
"type AggregateGovernment {
  count: Int!
}

type AggregateLobbyist {
  count: Int!
}

type AggregateMinister {
  count: Int!
}

type AggregateMinistry {
  count: Int!
}

type AggregateVote {
  count: Int!
}

enum BALLOT {
  YEA
  NAY
  ABSTAIN
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Government {
  id: ID!
  name: String
  country: String
  ministries(where: MinistryWhereInput, orderBy: MinistryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ministry!]
  lobbyists(where: LobbyistWhereInput, orderBy: LobbyistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lobbyist!]
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type GovernmentConnection {
  pageInfo: PageInfo!
  edges: [GovernmentEdge]!
  aggregate: AggregateGovernment!
}

input GovernmentCreateInput {
  name: String
  country: String
  ministries: MinistryCreateManyWithoutGovernmentInput
  lobbyists: LobbyistCreateManyWithoutGovernmentsInput
  deletedAt: DateTime
  deleted: Int
}

input GovernmentCreateManyWithoutLobbyistsInput {
  create: [GovernmentCreateWithoutLobbyistsInput!]
  connect: [GovernmentWhereUniqueInput!]
}

input GovernmentCreateOneWithoutMinistriesInput {
  create: GovernmentCreateWithoutMinistriesInput
  connect: GovernmentWhereUniqueInput
}

input GovernmentCreateWithoutLobbyistsInput {
  name: String
  country: String
  ministries: MinistryCreateManyWithoutGovernmentInput
  deletedAt: DateTime
  deleted: Int
}

input GovernmentCreateWithoutMinistriesInput {
  name: String
  country: String
  lobbyists: LobbyistCreateManyWithoutGovernmentsInput
  deletedAt: DateTime
  deleted: Int
}

type GovernmentEdge {
  node: Government!
  cursor: String!
}

enum GovernmentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  country_ASC
  country_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type GovernmentPreviousValues {
  id: ID!
  name: String
  country: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input GovernmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [GovernmentScalarWhereInput!]
  OR: [GovernmentScalarWhereInput!]
  NOT: [GovernmentScalarWhereInput!]
}

type GovernmentSubscriptionPayload {
  mutation: MutationType!
  node: Government
  updatedFields: [String!]
  previousValues: GovernmentPreviousValues
}

input GovernmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GovernmentWhereInput
  AND: [GovernmentSubscriptionWhereInput!]
  OR: [GovernmentSubscriptionWhereInput!]
  NOT: [GovernmentSubscriptionWhereInput!]
}

input GovernmentUpdateInput {
  name: String
  country: String
  ministries: MinistryUpdateManyWithoutGovernmentInput
  lobbyists: LobbyistUpdateManyWithoutGovernmentsInput
  deletedAt: DateTime
  deleted: Int
}

input GovernmentUpdateManyDataInput {
  name: String
  country: String
  deletedAt: DateTime
  deleted: Int
}

input GovernmentUpdateManyMutationInput {
  name: String
  country: String
  deletedAt: DateTime
  deleted: Int
}

input GovernmentUpdateManyWithoutLobbyistsInput {
  create: [GovernmentCreateWithoutLobbyistsInput!]
  delete: [GovernmentWhereUniqueInput!]
  connect: [GovernmentWhereUniqueInput!]
  set: [GovernmentWhereUniqueInput!]
  disconnect: [GovernmentWhereUniqueInput!]
  update: [GovernmentUpdateWithWhereUniqueWithoutLobbyistsInput!]
  upsert: [GovernmentUpsertWithWhereUniqueWithoutLobbyistsInput!]
  deleteMany: [GovernmentScalarWhereInput!]
  updateMany: [GovernmentUpdateManyWithWhereNestedInput!]
}

input GovernmentUpdateManyWithWhereNestedInput {
  where: GovernmentScalarWhereInput!
  data: GovernmentUpdateManyDataInput!
}

input GovernmentUpdateOneWithoutMinistriesInput {
  create: GovernmentCreateWithoutMinistriesInput
  update: GovernmentUpdateWithoutMinistriesDataInput
  upsert: GovernmentUpsertWithoutMinistriesInput
  delete: Boolean
  disconnect: Boolean
  connect: GovernmentWhereUniqueInput
}

input GovernmentUpdateWithoutLobbyistsDataInput {
  name: String
  country: String
  ministries: MinistryUpdateManyWithoutGovernmentInput
  deletedAt: DateTime
  deleted: Int
}

input GovernmentUpdateWithoutMinistriesDataInput {
  name: String
  country: String
  lobbyists: LobbyistUpdateManyWithoutGovernmentsInput
  deletedAt: DateTime
  deleted: Int
}

input GovernmentUpdateWithWhereUniqueWithoutLobbyistsInput {
  where: GovernmentWhereUniqueInput!
  data: GovernmentUpdateWithoutLobbyistsDataInput!
}

input GovernmentUpsertWithoutMinistriesInput {
  update: GovernmentUpdateWithoutMinistriesDataInput!
  create: GovernmentCreateWithoutMinistriesInput!
}

input GovernmentUpsertWithWhereUniqueWithoutLobbyistsInput {
  where: GovernmentWhereUniqueInput!
  update: GovernmentUpdateWithoutLobbyistsDataInput!
  create: GovernmentCreateWithoutLobbyistsInput!
}

input GovernmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  ministries_every: MinistryWhereInput
  ministries_some: MinistryWhereInput
  ministries_none: MinistryWhereInput
  lobbyists_every: LobbyistWhereInput
  lobbyists_some: LobbyistWhereInput
  lobbyists_none: LobbyistWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [GovernmentWhereInput!]
  OR: [GovernmentWhereInput!]
  NOT: [GovernmentWhereInput!]
}

input GovernmentWhereUniqueInput {
  id: ID
  country: String
}

scalar Json

type Lobbyist {
  id: ID!
  name: String
  governments(where: GovernmentWhereInput, orderBy: GovernmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Government!]
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type LobbyistConnection {
  pageInfo: PageInfo!
  edges: [LobbyistEdge]!
  aggregate: AggregateLobbyist!
}

input LobbyistCreateInput {
  name: String
  governments: GovernmentCreateManyWithoutLobbyistsInput
  deletedAt: DateTime
  deleted: Int
}

input LobbyistCreateManyWithoutGovernmentsInput {
  create: [LobbyistCreateWithoutGovernmentsInput!]
  connect: [LobbyistWhereUniqueInput!]
}

input LobbyistCreateWithoutGovernmentsInput {
  name: String
  deletedAt: DateTime
  deleted: Int
}

type LobbyistEdge {
  node: Lobbyist!
  cursor: String!
}

enum LobbyistOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type LobbyistPreviousValues {
  id: ID!
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input LobbyistScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [LobbyistScalarWhereInput!]
  OR: [LobbyistScalarWhereInput!]
  NOT: [LobbyistScalarWhereInput!]
}

type LobbyistSubscriptionPayload {
  mutation: MutationType!
  node: Lobbyist
  updatedFields: [String!]
  previousValues: LobbyistPreviousValues
}

input LobbyistSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LobbyistWhereInput
  AND: [LobbyistSubscriptionWhereInput!]
  OR: [LobbyistSubscriptionWhereInput!]
  NOT: [LobbyistSubscriptionWhereInput!]
}

input LobbyistUpdateInput {
  name: String
  governments: GovernmentUpdateManyWithoutLobbyistsInput
  deletedAt: DateTime
  deleted: Int
}

input LobbyistUpdateManyDataInput {
  name: String
  deletedAt: DateTime
  deleted: Int
}

input LobbyistUpdateManyMutationInput {
  name: String
  deletedAt: DateTime
  deleted: Int
}

input LobbyistUpdateManyWithoutGovernmentsInput {
  create: [LobbyistCreateWithoutGovernmentsInput!]
  delete: [LobbyistWhereUniqueInput!]
  connect: [LobbyistWhereUniqueInput!]
  set: [LobbyistWhereUniqueInput!]
  disconnect: [LobbyistWhereUniqueInput!]
  update: [LobbyistUpdateWithWhereUniqueWithoutGovernmentsInput!]
  upsert: [LobbyistUpsertWithWhereUniqueWithoutGovernmentsInput!]
  deleteMany: [LobbyistScalarWhereInput!]
  updateMany: [LobbyistUpdateManyWithWhereNestedInput!]
}

input LobbyistUpdateManyWithWhereNestedInput {
  where: LobbyistScalarWhereInput!
  data: LobbyistUpdateManyDataInput!
}

input LobbyistUpdateWithoutGovernmentsDataInput {
  name: String
  deletedAt: DateTime
  deleted: Int
}

input LobbyistUpdateWithWhereUniqueWithoutGovernmentsInput {
  where: LobbyistWhereUniqueInput!
  data: LobbyistUpdateWithoutGovernmentsDataInput!
}

input LobbyistUpsertWithWhereUniqueWithoutGovernmentsInput {
  where: LobbyistWhereUniqueInput!
  update: LobbyistUpdateWithoutGovernmentsDataInput!
  create: LobbyistCreateWithoutGovernmentsInput!
}

input LobbyistWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  governments_every: GovernmentWhereInput
  governments_some: GovernmentWhereInput
  governments_none: GovernmentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [LobbyistWhereInput!]
  OR: [LobbyistWhereInput!]
  NOT: [LobbyistWhereInput!]
}

input LobbyistWhereUniqueInput {
  id: ID
}

scalar Long

type Minister {
  id: ID!
  name: String
  votes(where: VoteWhereInput, orderBy: VoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vote!]
  ministry: Ministry
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type MinisterConnection {
  pageInfo: PageInfo!
  edges: [MinisterEdge]!
  aggregate: AggregateMinister!
}

input MinisterCreateInput {
  name: String
  votes: VoteCreateManyWithoutMinisterInput
  ministry: MinistryCreateOneWithoutMinisterInput
  deletedAt: DateTime
  deleted: Int
}

input MinisterCreateOneWithoutMinistryInput {
  create: MinisterCreateWithoutMinistryInput
  connect: MinisterWhereUniqueInput
}

input MinisterCreateOneWithoutVotesInput {
  create: MinisterCreateWithoutVotesInput
  connect: MinisterWhereUniqueInput
}

input MinisterCreateWithoutMinistryInput {
  name: String
  votes: VoteCreateManyWithoutMinisterInput
  deletedAt: DateTime
  deleted: Int
}

input MinisterCreateWithoutVotesInput {
  name: String
  ministry: MinistryCreateOneWithoutMinisterInput
  deletedAt: DateTime
  deleted: Int
}

type MinisterEdge {
  node: Minister!
  cursor: String!
}

enum MinisterOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type MinisterPreviousValues {
  id: ID!
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type MinisterSubscriptionPayload {
  mutation: MutationType!
  node: Minister
  updatedFields: [String!]
  previousValues: MinisterPreviousValues
}

input MinisterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MinisterWhereInput
  AND: [MinisterSubscriptionWhereInput!]
  OR: [MinisterSubscriptionWhereInput!]
  NOT: [MinisterSubscriptionWhereInput!]
}

input MinisterUpdateInput {
  name: String
  votes: VoteUpdateManyWithoutMinisterInput
  ministry: MinistryUpdateOneWithoutMinisterInput
  deletedAt: DateTime
  deleted: Int
}

input MinisterUpdateManyMutationInput {
  name: String
  deletedAt: DateTime
  deleted: Int
}

input MinisterUpdateOneWithoutMinistryInput {
  create: MinisterCreateWithoutMinistryInput
  update: MinisterUpdateWithoutMinistryDataInput
  upsert: MinisterUpsertWithoutMinistryInput
  delete: Boolean
  disconnect: Boolean
  connect: MinisterWhereUniqueInput
}

input MinisterUpdateOneWithoutVotesInput {
  create: MinisterCreateWithoutVotesInput
  update: MinisterUpdateWithoutVotesDataInput
  upsert: MinisterUpsertWithoutVotesInput
  delete: Boolean
  disconnect: Boolean
  connect: MinisterWhereUniqueInput
}

input MinisterUpdateWithoutMinistryDataInput {
  name: String
  votes: VoteUpdateManyWithoutMinisterInput
  deletedAt: DateTime
  deleted: Int
}

input MinisterUpdateWithoutVotesDataInput {
  name: String
  ministry: MinistryUpdateOneWithoutMinisterInput
  deletedAt: DateTime
  deleted: Int
}

input MinisterUpsertWithoutMinistryInput {
  update: MinisterUpdateWithoutMinistryDataInput!
  create: MinisterCreateWithoutMinistryInput!
}

input MinisterUpsertWithoutVotesInput {
  update: MinisterUpdateWithoutVotesDataInput!
  create: MinisterCreateWithoutVotesInput!
}

input MinisterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  votes_every: VoteWhereInput
  votes_some: VoteWhereInput
  votes_none: VoteWhereInput
  ministry: MinistryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [MinisterWhereInput!]
  OR: [MinisterWhereInput!]
  NOT: [MinisterWhereInput!]
}

input MinisterWhereUniqueInput {
  id: ID
}

type Ministry {
  id: ID!
  name: String
  budget: Float
  minister: Minister
  government: Government
  domains: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type MinistryConnection {
  pageInfo: PageInfo!
  edges: [MinistryEdge]!
  aggregate: AggregateMinistry!
}

input MinistryCreatedomainsInput {
  set: [String!]
}

input MinistryCreateInput {
  name: String
  budget: Float
  minister: MinisterCreateOneWithoutMinistryInput
  government: GovernmentCreateOneWithoutMinistriesInput
  domains: MinistryCreatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

input MinistryCreateManyWithoutGovernmentInput {
  create: [MinistryCreateWithoutGovernmentInput!]
  connect: [MinistryWhereUniqueInput!]
}

input MinistryCreateOneWithoutMinisterInput {
  create: MinistryCreateWithoutMinisterInput
  connect: MinistryWhereUniqueInput
}

input MinistryCreateWithoutGovernmentInput {
  name: String
  budget: Float
  minister: MinisterCreateOneWithoutMinistryInput
  domains: MinistryCreatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

input MinistryCreateWithoutMinisterInput {
  name: String
  budget: Float
  government: GovernmentCreateOneWithoutMinistriesInput
  domains: MinistryCreatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

type MinistryEdge {
  node: Ministry!
  cursor: String!
}

enum MinistryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  budget_ASC
  budget_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type MinistryPreviousValues {
  id: ID!
  name: String
  budget: Float
  domains: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input MinistryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  budget: Float
  budget_not: Float
  budget_in: [Float!]
  budget_not_in: [Float!]
  budget_lt: Float
  budget_lte: Float
  budget_gt: Float
  budget_gte: Float
  domains_contains: String
  domains_contains_some: [String!]
  domains_contains_every: [String!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [MinistryScalarWhereInput!]
  OR: [MinistryScalarWhereInput!]
  NOT: [MinistryScalarWhereInput!]
}

type MinistrySubscriptionPayload {
  mutation: MutationType!
  node: Ministry
  updatedFields: [String!]
  previousValues: MinistryPreviousValues
}

input MinistrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MinistryWhereInput
  AND: [MinistrySubscriptionWhereInput!]
  OR: [MinistrySubscriptionWhereInput!]
  NOT: [MinistrySubscriptionWhereInput!]
}

input MinistryUpdatedomainsInput {
  set: [String!]
}

input MinistryUpdateInput {
  name: String
  budget: Float
  minister: MinisterUpdateOneWithoutMinistryInput
  government: GovernmentUpdateOneWithoutMinistriesInput
  domains: MinistryUpdatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

input MinistryUpdateManyDataInput {
  name: String
  budget: Float
  domains: MinistryUpdatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

input MinistryUpdateManyMutationInput {
  name: String
  budget: Float
  domains: MinistryUpdatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

input MinistryUpdateManyWithoutGovernmentInput {
  create: [MinistryCreateWithoutGovernmentInput!]
  delete: [MinistryWhereUniqueInput!]
  connect: [MinistryWhereUniqueInput!]
  set: [MinistryWhereUniqueInput!]
  disconnect: [MinistryWhereUniqueInput!]
  update: [MinistryUpdateWithWhereUniqueWithoutGovernmentInput!]
  upsert: [MinistryUpsertWithWhereUniqueWithoutGovernmentInput!]
  deleteMany: [MinistryScalarWhereInput!]
  updateMany: [MinistryUpdateManyWithWhereNestedInput!]
}

input MinistryUpdateManyWithWhereNestedInput {
  where: MinistryScalarWhereInput!
  data: MinistryUpdateManyDataInput!
}

input MinistryUpdateOneWithoutMinisterInput {
  create: MinistryCreateWithoutMinisterInput
  update: MinistryUpdateWithoutMinisterDataInput
  upsert: MinistryUpsertWithoutMinisterInput
  delete: Boolean
  disconnect: Boolean
  connect: MinistryWhereUniqueInput
}

input MinistryUpdateWithoutGovernmentDataInput {
  name: String
  budget: Float
  minister: MinisterUpdateOneWithoutMinistryInput
  domains: MinistryUpdatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

input MinistryUpdateWithoutMinisterDataInput {
  name: String
  budget: Float
  government: GovernmentUpdateOneWithoutMinistriesInput
  domains: MinistryUpdatedomainsInput
  deletedAt: DateTime
  deleted: Int
}

input MinistryUpdateWithWhereUniqueWithoutGovernmentInput {
  where: MinistryWhereUniqueInput!
  data: MinistryUpdateWithoutGovernmentDataInput!
}

input MinistryUpsertWithoutMinisterInput {
  update: MinistryUpdateWithoutMinisterDataInput!
  create: MinistryCreateWithoutMinisterInput!
}

input MinistryUpsertWithWhereUniqueWithoutGovernmentInput {
  where: MinistryWhereUniqueInput!
  update: MinistryUpdateWithoutGovernmentDataInput!
  create: MinistryCreateWithoutGovernmentInput!
}

input MinistryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  budget: Float
  budget_not: Float
  budget_in: [Float!]
  budget_not_in: [Float!]
  budget_lt: Float
  budget_lte: Float
  budget_gt: Float
  budget_gte: Float
  minister: MinisterWhereInput
  government: GovernmentWhereInput
  domains_contains: String
  domains_contains_some: [String!]
  domains_contains_every: [String!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [MinistryWhereInput!]
  OR: [MinistryWhereInput!]
  NOT: [MinistryWhereInput!]
}

input MinistryWhereUniqueInput {
  id: ID
}

type Mutation {
  createGovernment(data: GovernmentCreateInput!): Government!
  updateGovernment(data: GovernmentUpdateInput!, where: GovernmentWhereUniqueInput!): Government
  updateManyGovernments(data: GovernmentUpdateManyMutationInput!, where: GovernmentWhereInput): BatchPayload!
  upsertGovernment(where: GovernmentWhereUniqueInput!, create: GovernmentCreateInput!, update: GovernmentUpdateInput!): Government!
  deleteGovernment(where: GovernmentWhereUniqueInput!): Government
  deleteManyGovernments(where: GovernmentWhereInput): BatchPayload!
  createLobbyist(data: LobbyistCreateInput!): Lobbyist!
  updateLobbyist(data: LobbyistUpdateInput!, where: LobbyistWhereUniqueInput!): Lobbyist
  updateManyLobbyists(data: LobbyistUpdateManyMutationInput!, where: LobbyistWhereInput): BatchPayload!
  upsertLobbyist(where: LobbyistWhereUniqueInput!, create: LobbyistCreateInput!, update: LobbyistUpdateInput!): Lobbyist!
  deleteLobbyist(where: LobbyistWhereUniqueInput!): Lobbyist
  deleteManyLobbyists(where: LobbyistWhereInput): BatchPayload!
  createMinister(data: MinisterCreateInput!): Minister!
  updateMinister(data: MinisterUpdateInput!, where: MinisterWhereUniqueInput!): Minister
  updateManyMinisters(data: MinisterUpdateManyMutationInput!, where: MinisterWhereInput): BatchPayload!
  upsertMinister(where: MinisterWhereUniqueInput!, create: MinisterCreateInput!, update: MinisterUpdateInput!): Minister!
  deleteMinister(where: MinisterWhereUniqueInput!): Minister
  deleteManyMinisters(where: MinisterWhereInput): BatchPayload!
  createMinistry(data: MinistryCreateInput!): Ministry!
  updateMinistry(data: MinistryUpdateInput!, where: MinistryWhereUniqueInput!): Ministry
  updateManyMinistries(data: MinistryUpdateManyMutationInput!, where: MinistryWhereInput): BatchPayload!
  upsertMinistry(where: MinistryWhereUniqueInput!, create: MinistryCreateInput!, update: MinistryUpdateInput!): Ministry!
  deleteMinistry(where: MinistryWhereUniqueInput!): Ministry
  deleteManyMinistries(where: MinistryWhereInput): BatchPayload!
  createVote(data: VoteCreateInput!): Vote!
  updateVote(data: VoteUpdateInput!, where: VoteWhereUniqueInput!): Vote
  updateManyVotes(data: VoteUpdateManyMutationInput!, where: VoteWhereInput): BatchPayload!
  upsertVote(where: VoteWhereUniqueInput!, create: VoteCreateInput!, update: VoteUpdateInput!): Vote!
  deleteVote(where: VoteWhereUniqueInput!): Vote
  deleteManyVotes(where: VoteWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  government(where: GovernmentWhereUniqueInput!): Government
  governments(where: GovernmentWhereInput, orderBy: GovernmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Government!]!
  governmentsConnection(where: GovernmentWhereInput, orderBy: GovernmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GovernmentConnection!
  lobbyist(where: LobbyistWhereUniqueInput!): Lobbyist
  lobbyists(where: LobbyistWhereInput, orderBy: LobbyistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lobbyist!]!
  lobbyistsConnection(where: LobbyistWhereInput, orderBy: LobbyistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LobbyistConnection!
  minister(where: MinisterWhereUniqueInput!): Minister
  ministers(where: MinisterWhereInput, orderBy: MinisterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Minister!]!
  ministersConnection(where: MinisterWhereInput, orderBy: MinisterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MinisterConnection!
  ministry(where: MinistryWhereUniqueInput!): Ministry
  ministries(where: MinistryWhereInput, orderBy: MinistryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ministry!]!
  ministriesConnection(where: MinistryWhereInput, orderBy: MinistryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MinistryConnection!
  vote(where: VoteWhereUniqueInput!): Vote
  votes(where: VoteWhereInput, orderBy: VoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vote!]!
  votesConnection(where: VoteWhereInput, orderBy: VoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VoteConnection!
  node(id: ID!): Node
}

type Subscription {
  government(where: GovernmentSubscriptionWhereInput): GovernmentSubscriptionPayload
  lobbyist(where: LobbyistSubscriptionWhereInput): LobbyistSubscriptionPayload
  minister(where: MinisterSubscriptionWhereInput): MinisterSubscriptionPayload
  ministry(where: MinistrySubscriptionWhereInput): MinistrySubscriptionPayload
  vote(where: VoteSubscriptionWhereInput): VoteSubscriptionPayload
}

type Vote {
  id: ID!
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  minister: Minister
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type VoteConnection {
  pageInfo: PageInfo!
  edges: [VoteEdge]!
  aggregate: AggregateVote!
}

input VoteCreateInput {
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  minister: MinisterCreateOneWithoutVotesInput
  deletedAt: DateTime
  deleted: Int
}

input VoteCreateManyWithoutMinisterInput {
  create: [VoteCreateWithoutMinisterInput!]
  connect: [VoteWhereUniqueInput!]
}

input VoteCreateWithoutMinisterInput {
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  deletedAt: DateTime
  deleted: Int
}

type VoteEdge {
  node: Vote!
  cursor: String!
}

enum VoteOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  ballot_ASC
  ballot_DESC
  lawInfo_ASC
  lawInfo_DESC
  lawInfoJson_ASC
  lawInfoJson_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type VotePreviousValues {
  id: ID!
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input VoteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  ballot: BALLOT
  ballot_not: BALLOT
  ballot_in: [BALLOT!]
  ballot_not_in: [BALLOT!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [VoteScalarWhereInput!]
  OR: [VoteScalarWhereInput!]
  NOT: [VoteScalarWhereInput!]
}

type VoteSubscriptionPayload {
  mutation: MutationType!
  node: Vote
  updatedFields: [String!]
  previousValues: VotePreviousValues
}

input VoteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VoteWhereInput
  AND: [VoteSubscriptionWhereInput!]
  OR: [VoteSubscriptionWhereInput!]
  NOT: [VoteSubscriptionWhereInput!]
}

input VoteUpdateInput {
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  minister: MinisterUpdateOneWithoutVotesInput
  deletedAt: DateTime
  deleted: Int
}

input VoteUpdateManyDataInput {
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  deletedAt: DateTime
  deleted: Int
}

input VoteUpdateManyMutationInput {
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  deletedAt: DateTime
  deleted: Int
}

input VoteUpdateManyWithoutMinisterInput {
  create: [VoteCreateWithoutMinisterInput!]
  delete: [VoteWhereUniqueInput!]
  connect: [VoteWhereUniqueInput!]
  set: [VoteWhereUniqueInput!]
  disconnect: [VoteWhereUniqueInput!]
  update: [VoteUpdateWithWhereUniqueWithoutMinisterInput!]
  upsert: [VoteUpsertWithWhereUniqueWithoutMinisterInput!]
  deleteMany: [VoteScalarWhereInput!]
  updateMany: [VoteUpdateManyWithWhereNestedInput!]
}

input VoteUpdateManyWithWhereNestedInput {
  where: VoteScalarWhereInput!
  data: VoteUpdateManyDataInput!
}

input VoteUpdateWithoutMinisterDataInput {
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  deletedAt: DateTime
  deleted: Int
}

input VoteUpdateWithWhereUniqueWithoutMinisterInput {
  where: VoteWhereUniqueInput!
  data: VoteUpdateWithoutMinisterDataInput!
}

input VoteUpsertWithWhereUniqueWithoutMinisterInput {
  where: VoteWhereUniqueInput!
  update: VoteUpdateWithoutMinisterDataInput!
  create: VoteCreateWithoutMinisterInput!
}

input VoteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  ballot: BALLOT
  ballot_not: BALLOT
  ballot_in: [BALLOT!]
  ballot_not_in: [BALLOT!]
  minister: MinisterWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [VoteWhereInput!]
  OR: [VoteWhereInput!]
  NOT: [VoteWhereInput!]
}

input VoteWhereUniqueInput {
  id: ID
}
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 8`] = `
"export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
  Json: any;
  Long: any;
};

export type AggregateGovernment = {
  __typename?: 'AggregateGovernment';
  count: Scalars['Int'];
};

export type AggregateLobbyist = {
  __typename?: 'AggregateLobbyist';
  count: Scalars['Int'];
};

export type AggregateMinister = {
  __typename?: 'AggregateMinister';
  count: Scalars['Int'];
};

export type AggregateMinistry = {
  __typename?: 'AggregateMinistry';
  count: Scalars['Int'];
};

export type AggregateVote = {
  __typename?: 'AggregateVote';
  count: Scalars['Int'];
};

export enum Ballot {
  YEA = 'YEA',
  NAY = 'NAY',
  ABSTAIN = 'ABSTAIN'
}

export type BatchPayload = {
  __typename?: 'BatchPayload';
  count: Scalars['Long'];
};


export type Government = {
  __typename?: 'Government';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  ministries?: Maybe<Array<Ministry>>;
  lobbyists?: Maybe<Array<Lobbyist>>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
};


export type GovernmentMinistriesArgs = {
  where?: Maybe<MinistryWhereInput>;
  orderBy?: Maybe<MinistryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type GovernmentLobbyistsArgs = {
  where?: Maybe<LobbyistWhereInput>;
  orderBy?: Maybe<LobbyistOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type GovernmentConnection = {
  __typename?: 'GovernmentConnection';
  pageInfo: PageInfo;
  edges: Array<Maybe<GovernmentEdge>>;
  aggregate: AggregateGovernment;
};

export type GovernmentCreateInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  ministries?: Maybe<MinistryCreateManyWithoutGovernmentInput>;
  lobbyists?: Maybe<LobbyistCreateManyWithoutGovernmentsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentCreateManyWithoutLobbyistsInput = {
  create?: Maybe<Array<GovernmentCreateWithoutLobbyistsInput>>;
  connect?: Maybe<Array<GovernmentWhereUniqueInput>>;
};

export type GovernmentCreateOneWithoutMinistriesInput = {
  create?: Maybe<GovernmentCreateWithoutMinistriesInput>;
  connect?: Maybe<GovernmentWhereUniqueInput>;
};

export type GovernmentCreateWithoutLobbyistsInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  ministries?: Maybe<MinistryCreateManyWithoutGovernmentInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentCreateWithoutMinistriesInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  lobbyists?: Maybe<LobbyistCreateManyWithoutGovernmentsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentEdge = {
  __typename?: 'GovernmentEdge';
  node: Government;
  cursor: Scalars['String'];
};

export enum GovernmentOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  NAME_ASC = 'name_ASC',
  NAME_DESC = 'name_DESC',
  COUNTRY_ASC = 'country_ASC',
  COUNTRY_DESC = 'country_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type GovernmentPreviousValues = {
  __typename?: 'GovernmentPreviousValues';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
};

export type GovernmentScalarWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  country_not?: Maybe<Scalars['String']>;
  country_in?: Maybe<Array<Scalars['String']>>;
  country_not_in?: Maybe<Array<Scalars['String']>>;
  country_lt?: Maybe<Scalars['String']>;
  country_lte?: Maybe<Scalars['String']>;
  country_gt?: Maybe<Scalars['String']>;
  country_gte?: Maybe<Scalars['String']>;
  country_contains?: Maybe<Scalars['String']>;
  country_not_contains?: Maybe<Scalars['String']>;
  country_starts_with?: Maybe<Scalars['String']>;
  country_not_starts_with?: Maybe<Scalars['String']>;
  country_ends_with?: Maybe<Scalars['String']>;
  country_not_ends_with?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<GovernmentScalarWhereInput>>;
  OR?: Maybe<Array<GovernmentScalarWhereInput>>;
  NOT?: Maybe<Array<GovernmentScalarWhereInput>>;
};

export type GovernmentSubscriptionPayload = {
  __typename?: 'GovernmentSubscriptionPayload';
  mutation: MutationType;
  node?: Maybe<Government>;
  updatedFields?: Maybe<Array<Scalars['String']>>;
  previousValues?: Maybe<GovernmentPreviousValues>;
};

export type GovernmentSubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>;
  updatedFields_contains?: Maybe<Scalars['String']>;
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>;
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>;
  node?: Maybe<GovernmentWhereInput>;
  AND?: Maybe<Array<GovernmentSubscriptionWhereInput>>;
  OR?: Maybe<Array<GovernmentSubscriptionWhereInput>>;
  NOT?: Maybe<Array<GovernmentSubscriptionWhereInput>>;
};

export type GovernmentUpdateInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  ministries?: Maybe<MinistryUpdateManyWithoutGovernmentInput>;
  lobbyists?: Maybe<LobbyistUpdateManyWithoutGovernmentsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentUpdateManyDataInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentUpdateManyMutationInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentUpdateManyWithoutLobbyistsInput = {
  create?: Maybe<Array<GovernmentCreateWithoutLobbyistsInput>>;
  delete?: Maybe<Array<GovernmentWhereUniqueInput>>;
  connect?: Maybe<Array<GovernmentWhereUniqueInput>>;
  set?: Maybe<Array<GovernmentWhereUniqueInput>>;
  disconnect?: Maybe<Array<GovernmentWhereUniqueInput>>;
  update?: Maybe<Array<GovernmentUpdateWithWhereUniqueWithoutLobbyistsInput>>;
  upsert?: Maybe<Array<GovernmentUpsertWithWhereUniqueWithoutLobbyistsInput>>;
  deleteMany?: Maybe<Array<GovernmentScalarWhereInput>>;
  updateMany?: Maybe<Array<GovernmentUpdateManyWithWhereNestedInput>>;
};

export type GovernmentUpdateManyWithWhereNestedInput = {
  where: GovernmentScalarWhereInput;
  data: GovernmentUpdateManyDataInput;
};

export type GovernmentUpdateOneWithoutMinistriesInput = {
  create?: Maybe<GovernmentCreateWithoutMinistriesInput>;
  update?: Maybe<GovernmentUpdateWithoutMinistriesDataInput>;
  upsert?: Maybe<GovernmentUpsertWithoutMinistriesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  connect?: Maybe<GovernmentWhereUniqueInput>;
};

export type GovernmentUpdateWithoutLobbyistsDataInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  ministries?: Maybe<MinistryUpdateManyWithoutGovernmentInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentUpdateWithoutMinistriesDataInput = {
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  lobbyists?: Maybe<LobbyistUpdateManyWithoutGovernmentsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type GovernmentUpdateWithWhereUniqueWithoutLobbyistsInput = {
  where: GovernmentWhereUniqueInput;
  data: GovernmentUpdateWithoutLobbyistsDataInput;
};

export type GovernmentUpsertWithoutMinistriesInput = {
  update: GovernmentUpdateWithoutMinistriesDataInput;
  create: GovernmentCreateWithoutMinistriesInput;
};

export type GovernmentUpsertWithWhereUniqueWithoutLobbyistsInput = {
  where: GovernmentWhereUniqueInput;
  update: GovernmentUpdateWithoutLobbyistsDataInput;
  create: GovernmentCreateWithoutLobbyistsInput;
};

export type GovernmentWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  country_not?: Maybe<Scalars['String']>;
  country_in?: Maybe<Array<Scalars['String']>>;
  country_not_in?: Maybe<Array<Scalars['String']>>;
  country_lt?: Maybe<Scalars['String']>;
  country_lte?: Maybe<Scalars['String']>;
  country_gt?: Maybe<Scalars['String']>;
  country_gte?: Maybe<Scalars['String']>;
  country_contains?: Maybe<Scalars['String']>;
  country_not_contains?: Maybe<Scalars['String']>;
  country_starts_with?: Maybe<Scalars['String']>;
  country_not_starts_with?: Maybe<Scalars['String']>;
  country_ends_with?: Maybe<Scalars['String']>;
  country_not_ends_with?: Maybe<Scalars['String']>;
  ministries_every?: Maybe<MinistryWhereInput>;
  ministries_some?: Maybe<MinistryWhereInput>;
  ministries_none?: Maybe<MinistryWhereInput>;
  lobbyists_every?: Maybe<LobbyistWhereInput>;
  lobbyists_some?: Maybe<LobbyistWhereInput>;
  lobbyists_none?: Maybe<LobbyistWhereInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<GovernmentWhereInput>>;
  OR?: Maybe<Array<GovernmentWhereInput>>;
  NOT?: Maybe<Array<GovernmentWhereInput>>;
};

export type GovernmentWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>;
  country?: Maybe<Scalars['String']>;
};


export type Lobbyist = {
  __typename?: 'Lobbyist';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  governments?: Maybe<Array<Government>>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
};


export type LobbyistGovernmentsArgs = {
  where?: Maybe<GovernmentWhereInput>;
  orderBy?: Maybe<GovernmentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type LobbyistConnection = {
  __typename?: 'LobbyistConnection';
  pageInfo: PageInfo;
  edges: Array<Maybe<LobbyistEdge>>;
  aggregate: AggregateLobbyist;
};

export type LobbyistCreateInput = {
  name?: Maybe<Scalars['String']>;
  governments?: Maybe<GovernmentCreateManyWithoutLobbyistsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type LobbyistCreateManyWithoutGovernmentsInput = {
  create?: Maybe<Array<LobbyistCreateWithoutGovernmentsInput>>;
  connect?: Maybe<Array<LobbyistWhereUniqueInput>>;
};

export type LobbyistCreateWithoutGovernmentsInput = {
  name?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type LobbyistEdge = {
  __typename?: 'LobbyistEdge';
  node: Lobbyist;
  cursor: Scalars['String'];
};

export enum LobbyistOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  NAME_ASC = 'name_ASC',
  NAME_DESC = 'name_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type LobbyistPreviousValues = {
  __typename?: 'LobbyistPreviousValues';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
};

export type LobbyistScalarWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<LobbyistScalarWhereInput>>;
  OR?: Maybe<Array<LobbyistScalarWhereInput>>;
  NOT?: Maybe<Array<LobbyistScalarWhereInput>>;
};

export type LobbyistSubscriptionPayload = {
  __typename?: 'LobbyistSubscriptionPayload';
  mutation: MutationType;
  node?: Maybe<Lobbyist>;
  updatedFields?: Maybe<Array<Scalars['String']>>;
  previousValues?: Maybe<LobbyistPreviousValues>;
};

export type LobbyistSubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>;
  updatedFields_contains?: Maybe<Scalars['String']>;
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>;
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>;
  node?: Maybe<LobbyistWhereInput>;
  AND?: Maybe<Array<LobbyistSubscriptionWhereInput>>;
  OR?: Maybe<Array<LobbyistSubscriptionWhereInput>>;
  NOT?: Maybe<Array<LobbyistSubscriptionWhereInput>>;
};

export type LobbyistUpdateInput = {
  name?: Maybe<Scalars['String']>;
  governments?: Maybe<GovernmentUpdateManyWithoutLobbyistsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type LobbyistUpdateManyDataInput = {
  name?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type LobbyistUpdateManyMutationInput = {
  name?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type LobbyistUpdateManyWithoutGovernmentsInput = {
  create?: Maybe<Array<LobbyistCreateWithoutGovernmentsInput>>;
  delete?: Maybe<Array<LobbyistWhereUniqueInput>>;
  connect?: Maybe<Array<LobbyistWhereUniqueInput>>;
  set?: Maybe<Array<LobbyistWhereUniqueInput>>;
  disconnect?: Maybe<Array<LobbyistWhereUniqueInput>>;
  update?: Maybe<Array<LobbyistUpdateWithWhereUniqueWithoutGovernmentsInput>>;
  upsert?: Maybe<Array<LobbyistUpsertWithWhereUniqueWithoutGovernmentsInput>>;
  deleteMany?: Maybe<Array<LobbyistScalarWhereInput>>;
  updateMany?: Maybe<Array<LobbyistUpdateManyWithWhereNestedInput>>;
};

export type LobbyistUpdateManyWithWhereNestedInput = {
  where: LobbyistScalarWhereInput;
  data: LobbyistUpdateManyDataInput;
};

export type LobbyistUpdateWithoutGovernmentsDataInput = {
  name?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type LobbyistUpdateWithWhereUniqueWithoutGovernmentsInput = {
  where: LobbyistWhereUniqueInput;
  data: LobbyistUpdateWithoutGovernmentsDataInput;
};

export type LobbyistUpsertWithWhereUniqueWithoutGovernmentsInput = {
  where: LobbyistWhereUniqueInput;
  update: LobbyistUpdateWithoutGovernmentsDataInput;
  create: LobbyistCreateWithoutGovernmentsInput;
};

export type LobbyistWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  governments_every?: Maybe<GovernmentWhereInput>;
  governments_some?: Maybe<GovernmentWhereInput>;
  governments_none?: Maybe<GovernmentWhereInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<LobbyistWhereInput>>;
  OR?: Maybe<Array<LobbyistWhereInput>>;
  NOT?: Maybe<Array<LobbyistWhereInput>>;
};

export type LobbyistWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>;
};


export type Minister = {
  __typename?: 'Minister';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  votes?: Maybe<Array<Vote>>;
  ministry?: Maybe<Ministry>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
  ministryId?: Maybe<Scalars['ID']>;
};


export type MinisterVotesArgs = {
  where?: Maybe<VoteWhereInput>;
  orderBy?: Maybe<VoteOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type MinisterConnection = {
  __typename?: 'MinisterConnection';
  pageInfo: PageInfo;
  edges: Array<Maybe<MinisterEdge>>;
  aggregate: AggregateMinister;
};

export type MinisterCreateInput = {
  name?: Maybe<Scalars['String']>;
  votes?: Maybe<VoteCreateManyWithoutMinisterInput>;
  ministry?: Maybe<MinistryCreateOneWithoutMinisterInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinisterCreateOneWithoutMinistryInput = {
  create?: Maybe<MinisterCreateWithoutMinistryInput>;
  connect?: Maybe<MinisterWhereUniqueInput>;
};

export type MinisterCreateOneWithoutVotesInput = {
  create?: Maybe<MinisterCreateWithoutVotesInput>;
  connect?: Maybe<MinisterWhereUniqueInput>;
};

export type MinisterCreateWithoutMinistryInput = {
  name?: Maybe<Scalars['String']>;
  votes?: Maybe<VoteCreateManyWithoutMinisterInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinisterCreateWithoutVotesInput = {
  name?: Maybe<Scalars['String']>;
  ministry?: Maybe<MinistryCreateOneWithoutMinisterInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinisterEdge = {
  __typename?: 'MinisterEdge';
  node: Minister;
  cursor: Scalars['String'];
};

export enum MinisterOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  NAME_ASC = 'name_ASC',
  NAME_DESC = 'name_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type MinisterPreviousValues = {
  __typename?: 'MinisterPreviousValues';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
};

export type MinisterSubscriptionPayload = {
  __typename?: 'MinisterSubscriptionPayload';
  mutation: MutationType;
  node?: Maybe<Minister>;
  updatedFields?: Maybe<Array<Scalars['String']>>;
  previousValues?: Maybe<MinisterPreviousValues>;
};

export type MinisterSubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>;
  updatedFields_contains?: Maybe<Scalars['String']>;
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>;
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>;
  node?: Maybe<MinisterWhereInput>;
  AND?: Maybe<Array<MinisterSubscriptionWhereInput>>;
  OR?: Maybe<Array<MinisterSubscriptionWhereInput>>;
  NOT?: Maybe<Array<MinisterSubscriptionWhereInput>>;
};

export type MinisterUpdateInput = {
  name?: Maybe<Scalars['String']>;
  votes?: Maybe<VoteUpdateManyWithoutMinisterInput>;
  ministry?: Maybe<MinistryUpdateOneWithoutMinisterInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinisterUpdateManyMutationInput = {
  name?: Maybe<Scalars['String']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinisterUpdateOneWithoutMinistryInput = {
  create?: Maybe<MinisterCreateWithoutMinistryInput>;
  update?: Maybe<MinisterUpdateWithoutMinistryDataInput>;
  upsert?: Maybe<MinisterUpsertWithoutMinistryInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  connect?: Maybe<MinisterWhereUniqueInput>;
};

export type MinisterUpdateOneWithoutVotesInput = {
  create?: Maybe<MinisterCreateWithoutVotesInput>;
  update?: Maybe<MinisterUpdateWithoutVotesDataInput>;
  upsert?: Maybe<MinisterUpsertWithoutVotesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  connect?: Maybe<MinisterWhereUniqueInput>;
};

export type MinisterUpdateWithoutMinistryDataInput = {
  name?: Maybe<Scalars['String']>;
  votes?: Maybe<VoteUpdateManyWithoutMinisterInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinisterUpdateWithoutVotesDataInput = {
  name?: Maybe<Scalars['String']>;
  ministry?: Maybe<MinistryUpdateOneWithoutMinisterInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinisterUpsertWithoutMinistryInput = {
  update: MinisterUpdateWithoutMinistryDataInput;
  create: MinisterCreateWithoutMinistryInput;
};

export type MinisterUpsertWithoutVotesInput = {
  update: MinisterUpdateWithoutVotesDataInput;
  create: MinisterCreateWithoutVotesInput;
};

export type MinisterWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  votes_every?: Maybe<VoteWhereInput>;
  votes_some?: Maybe<VoteWhereInput>;
  votes_none?: Maybe<VoteWhereInput>;
  ministry?: Maybe<MinistryWhereInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<MinisterWhereInput>>;
  OR?: Maybe<Array<MinisterWhereInput>>;
  NOT?: Maybe<Array<MinisterWhereInput>>;
};

export type MinisterWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>;
};

export type Ministry = {
  __typename?: 'Ministry';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  minister?: Maybe<Minister>;
  government?: Maybe<Government>;
  domains: Array<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
  ministerId?: Maybe<Scalars['ID']>;
  governmentId?: Maybe<Scalars['ID']>;
};

export type MinistryConnection = {
  __typename?: 'MinistryConnection';
  pageInfo: PageInfo;
  edges: Array<Maybe<MinistryEdge>>;
  aggregate: AggregateMinistry;
};

export type MinistryCreatedomainsInput = {
  set?: Maybe<Array<Scalars['String']>>;
};

export type MinistryCreateInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  minister?: Maybe<MinisterCreateOneWithoutMinistryInput>;
  government?: Maybe<GovernmentCreateOneWithoutMinistriesInput>;
  domains?: Maybe<MinistryCreatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryCreateManyWithoutGovernmentInput = {
  create?: Maybe<Array<MinistryCreateWithoutGovernmentInput>>;
  connect?: Maybe<Array<MinistryWhereUniqueInput>>;
};

export type MinistryCreateOneWithoutMinisterInput = {
  create?: Maybe<MinistryCreateWithoutMinisterInput>;
  connect?: Maybe<MinistryWhereUniqueInput>;
};

export type MinistryCreateWithoutGovernmentInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  minister?: Maybe<MinisterCreateOneWithoutMinistryInput>;
  domains?: Maybe<MinistryCreatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryCreateWithoutMinisterInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  government?: Maybe<GovernmentCreateOneWithoutMinistriesInput>;
  domains?: Maybe<MinistryCreatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryEdge = {
  __typename?: 'MinistryEdge';
  node: Ministry;
  cursor: Scalars['String'];
};

export enum MinistryOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  NAME_ASC = 'name_ASC',
  NAME_DESC = 'name_DESC',
  BUDGET_ASC = 'budget_ASC',
  BUDGET_DESC = 'budget_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type MinistryPreviousValues = {
  __typename?: 'MinistryPreviousValues';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  domains: Array<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
};

export type MinistryScalarWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  budget_not?: Maybe<Scalars['Float']>;
  budget_in?: Maybe<Array<Scalars['Float']>>;
  budget_not_in?: Maybe<Array<Scalars['Float']>>;
  budget_lt?: Maybe<Scalars['Float']>;
  budget_lte?: Maybe<Scalars['Float']>;
  budget_gt?: Maybe<Scalars['Float']>;
  budget_gte?: Maybe<Scalars['Float']>;
  domains_contains?: Maybe<Scalars['String']>;
  domains_contains_some?: Maybe<Array<Scalars['String']>>;
  domains_contains_every?: Maybe<Array<Scalars['String']>>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<MinistryScalarWhereInput>>;
  OR?: Maybe<Array<MinistryScalarWhereInput>>;
  NOT?: Maybe<Array<MinistryScalarWhereInput>>;
};

export type MinistrySubscriptionPayload = {
  __typename?: 'MinistrySubscriptionPayload';
  mutation: MutationType;
  node?: Maybe<Ministry>;
  updatedFields?: Maybe<Array<Scalars['String']>>;
  previousValues?: Maybe<MinistryPreviousValues>;
};

export type MinistrySubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>;
  updatedFields_contains?: Maybe<Scalars['String']>;
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>;
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>;
  node?: Maybe<MinistryWhereInput>;
  AND?: Maybe<Array<MinistrySubscriptionWhereInput>>;
  OR?: Maybe<Array<MinistrySubscriptionWhereInput>>;
  NOT?: Maybe<Array<MinistrySubscriptionWhereInput>>;
};

export type MinistryUpdatedomainsInput = {
  set?: Maybe<Array<Scalars['String']>>;
};

export type MinistryUpdateInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  minister?: Maybe<MinisterUpdateOneWithoutMinistryInput>;
  government?: Maybe<GovernmentUpdateOneWithoutMinistriesInput>;
  domains?: Maybe<MinistryUpdatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryUpdateManyDataInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  domains?: Maybe<MinistryUpdatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryUpdateManyMutationInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  domains?: Maybe<MinistryUpdatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryUpdateManyWithoutGovernmentInput = {
  create?: Maybe<Array<MinistryCreateWithoutGovernmentInput>>;
  delete?: Maybe<Array<MinistryWhereUniqueInput>>;
  connect?: Maybe<Array<MinistryWhereUniqueInput>>;
  set?: Maybe<Array<MinistryWhereUniqueInput>>;
  disconnect?: Maybe<Array<MinistryWhereUniqueInput>>;
  update?: Maybe<Array<MinistryUpdateWithWhereUniqueWithoutGovernmentInput>>;
  upsert?: Maybe<Array<MinistryUpsertWithWhereUniqueWithoutGovernmentInput>>;
  deleteMany?: Maybe<Array<MinistryScalarWhereInput>>;
  updateMany?: Maybe<Array<MinistryUpdateManyWithWhereNestedInput>>;
};

export type MinistryUpdateManyWithWhereNestedInput = {
  where: MinistryScalarWhereInput;
  data: MinistryUpdateManyDataInput;
};

export type MinistryUpdateOneWithoutMinisterInput = {
  create?: Maybe<MinistryCreateWithoutMinisterInput>;
  update?: Maybe<MinistryUpdateWithoutMinisterDataInput>;
  upsert?: Maybe<MinistryUpsertWithoutMinisterInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  connect?: Maybe<MinistryWhereUniqueInput>;
};

export type MinistryUpdateWithoutGovernmentDataInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  minister?: Maybe<MinisterUpdateOneWithoutMinistryInput>;
  domains?: Maybe<MinistryUpdatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryUpdateWithoutMinisterDataInput = {
  name?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  government?: Maybe<GovernmentUpdateOneWithoutMinistriesInput>;
  domains?: Maybe<MinistryUpdatedomainsInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type MinistryUpdateWithWhereUniqueWithoutGovernmentInput = {
  where: MinistryWhereUniqueInput;
  data: MinistryUpdateWithoutGovernmentDataInput;
};

export type MinistryUpsertWithoutMinisterInput = {
  update: MinistryUpdateWithoutMinisterDataInput;
  create: MinistryCreateWithoutMinisterInput;
};

export type MinistryUpsertWithWhereUniqueWithoutGovernmentInput = {
  where: MinistryWhereUniqueInput;
  update: MinistryUpdateWithoutGovernmentDataInput;
  create: MinistryCreateWithoutGovernmentInput;
};

export type MinistryWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  budget?: Maybe<Scalars['Float']>;
  budget_not?: Maybe<Scalars['Float']>;
  budget_in?: Maybe<Array<Scalars['Float']>>;
  budget_not_in?: Maybe<Array<Scalars['Float']>>;
  budget_lt?: Maybe<Scalars['Float']>;
  budget_lte?: Maybe<Scalars['Float']>;
  budget_gt?: Maybe<Scalars['Float']>;
  budget_gte?: Maybe<Scalars['Float']>;
  minister?: Maybe<MinisterWhereInput>;
  government?: Maybe<GovernmentWhereInput>;
  domains_contains?: Maybe<Scalars['String']>;
  domains_contains_some?: Maybe<Array<Scalars['String']>>;
  domains_contains_every?: Maybe<Array<Scalars['String']>>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<MinistryWhereInput>>;
  OR?: Maybe<Array<MinistryWhereInput>>;
  NOT?: Maybe<Array<MinistryWhereInput>>;
};

export type MinistryWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createMinistry: Ministry;
  updateMinistry?: Maybe<Ministry>;
  updateManyMinistries: BatchPayload;
  upsertMinistry: Ministry;
  deleteMinistry?: Maybe<Ministry>;
  deleteManyMinistries: BatchPayload;
  createMinister: Minister;
  updateMinister?: Maybe<Minister>;
  updateManyMinisters: BatchPayload;
  upsertMinister: Minister;
  deleteMinister?: Maybe<Minister>;
  deleteManyMinisters: BatchPayload;
  createGovernment: Government;
  updateGovernment?: Maybe<Government>;
  updateManyGovernments: BatchPayload;
  upsertGovernment: Government;
  deleteGovernment?: Maybe<Government>;
  deleteManyGovernments: BatchPayload;
  createVote: Vote;
  updateVote?: Maybe<Vote>;
  updateManyVotes: BatchPayload;
  upsertVote: Vote;
  deleteVote?: Maybe<Vote>;
  deleteManyVotes: BatchPayload;
  createLobbyist: Lobbyist;
  updateLobbyist?: Maybe<Lobbyist>;
  updateManyLobbyists: BatchPayload;
  upsertLobbyist: Lobbyist;
  deleteLobbyist?: Maybe<Lobbyist>;
  deleteManyLobbyists: BatchPayload;
};


export type MutationCreateMinistryArgs = {
  data: MinistryCreateInput;
};


export type MutationUpdateMinistryArgs = {
  data: MinistryUpdateInput;
  where: MinistryWhereUniqueInput;
};


export type MutationUpdateManyMinistriesArgs = {
  data: MinistryUpdateManyMutationInput;
  where?: Maybe<MinistryWhereInput>;
};


export type MutationUpsertMinistryArgs = {
  where: MinistryWhereUniqueInput;
  create: MinistryCreateInput;
  update: MinistryUpdateInput;
};


export type MutationDeleteMinistryArgs = {
  where: MinistryWhereUniqueInput;
};


export type MutationDeleteManyMinistriesArgs = {
  where?: Maybe<MinistryWhereInput>;
};


export type MutationCreateMinisterArgs = {
  data: MinisterCreateInput;
};


export type MutationUpdateMinisterArgs = {
  data: MinisterUpdateInput;
  where: MinisterWhereUniqueInput;
};


export type MutationUpdateManyMinistersArgs = {
  data: MinisterUpdateManyMutationInput;
  where?: Maybe<MinisterWhereInput>;
};


export type MutationUpsertMinisterArgs = {
  where: MinisterWhereUniqueInput;
  create: MinisterCreateInput;
  update: MinisterUpdateInput;
};


export type MutationDeleteMinisterArgs = {
  where: MinisterWhereUniqueInput;
};


export type MutationDeleteManyMinistersArgs = {
  where?: Maybe<MinisterWhereInput>;
};


export type MutationCreateGovernmentArgs = {
  data: GovernmentCreateInput;
};


export type MutationUpdateGovernmentArgs = {
  data: GovernmentUpdateInput;
  where: GovernmentWhereUniqueInput;
};


export type MutationUpdateManyGovernmentsArgs = {
  data: GovernmentUpdateManyMutationInput;
  where?: Maybe<GovernmentWhereInput>;
};


export type MutationUpsertGovernmentArgs = {
  where: GovernmentWhereUniqueInput;
  create: GovernmentCreateInput;
  update: GovernmentUpdateInput;
};


export type MutationDeleteGovernmentArgs = {
  where: GovernmentWhereUniqueInput;
};


export type MutationDeleteManyGovernmentsArgs = {
  where?: Maybe<GovernmentWhereInput>;
};


export type MutationCreateVoteArgs = {
  data: VoteCreateInput;
};


export type MutationUpdateVoteArgs = {
  data: VoteUpdateInput;
  where: VoteWhereUniqueInput;
};


export type MutationUpdateManyVotesArgs = {
  data: VoteUpdateManyMutationInput;
  where?: Maybe<VoteWhereInput>;
};


export type MutationUpsertVoteArgs = {
  where: VoteWhereUniqueInput;
  create: VoteCreateInput;
  update: VoteUpdateInput;
};


export type MutationDeleteVoteArgs = {
  where: VoteWhereUniqueInput;
};


export type MutationDeleteManyVotesArgs = {
  where?: Maybe<VoteWhereInput>;
};


export type MutationCreateLobbyistArgs = {
  data: LobbyistCreateInput;
};


export type MutationUpdateLobbyistArgs = {
  data: LobbyistUpdateInput;
  where: LobbyistWhereUniqueInput;
};


export type MutationUpdateManyLobbyistsArgs = {
  data: LobbyistUpdateManyMutationInput;
  where?: Maybe<LobbyistWhereInput>;
};


export type MutationUpsertLobbyistArgs = {
  where: LobbyistWhereUniqueInput;
  create: LobbyistCreateInput;
  update: LobbyistUpdateInput;
};


export type MutationDeleteLobbyistArgs = {
  where: LobbyistWhereUniqueInput;
};


export type MutationDeleteManyLobbyistsArgs = {
  where?: Maybe<LobbyistWhereInput>;
};

export enum MutationType {
  CREATED = 'CREATED',
  UPDATED = 'UPDATED',
  DELETED = 'DELETED'
}

export type Node = {
  id: Scalars['ID'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['String']>;
  endCursor?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  ministry?: Maybe<Ministry>;
  ministries: Array<Ministry>;
  ministriesConnection: MinistryConnection;
  minister?: Maybe<Minister>;
  ministers: Array<Minister>;
  ministersConnection: MinisterConnection;
  government?: Maybe<Government>;
  governments: Array<Government>;
  governmentsConnection: GovernmentConnection;
  vote?: Maybe<Vote>;
  votes: Array<Vote>;
  votesConnection: VoteConnection;
  lobbyist?: Maybe<Lobbyist>;
  lobbyists: Array<Lobbyist>;
  lobbyistsConnection: LobbyistConnection;
  node?: Maybe<Node>;
};


export type QueryMinistryArgs = {
  where: MinistryWhereUniqueInput;
};


export type QueryMinistriesArgs = {
  where?: Maybe<MinistryWhereInput>;
  orderBy?: Maybe<MinistryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryMinistriesConnectionArgs = {
  where?: Maybe<MinistryWhereInput>;
  orderBy?: Maybe<MinistryOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryMinisterArgs = {
  where: MinisterWhereUniqueInput;
};


export type QueryMinistersArgs = {
  where?: Maybe<MinisterWhereInput>;
  orderBy?: Maybe<MinisterOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryMinistersConnectionArgs = {
  where?: Maybe<MinisterWhereInput>;
  orderBy?: Maybe<MinisterOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryGovernmentArgs = {
  where: GovernmentWhereUniqueInput;
};


export type QueryGovernmentsArgs = {
  where?: Maybe<GovernmentWhereInput>;
  orderBy?: Maybe<GovernmentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryGovernmentsConnectionArgs = {
  where?: Maybe<GovernmentWhereInput>;
  orderBy?: Maybe<GovernmentOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryVoteArgs = {
  where: VoteWhereUniqueInput;
};


export type QueryVotesArgs = {
  where?: Maybe<VoteWhereInput>;
  orderBy?: Maybe<VoteOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryVotesConnectionArgs = {
  where?: Maybe<VoteWhereInput>;
  orderBy?: Maybe<VoteOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryLobbyistArgs = {
  where: LobbyistWhereUniqueInput;
};


export type QueryLobbyistsArgs = {
  where?: Maybe<LobbyistWhereInput>;
  orderBy?: Maybe<LobbyistOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryLobbyistsConnectionArgs = {
  where?: Maybe<LobbyistWhereInput>;
  orderBy?: Maybe<LobbyistOrderByInput>;
  skip?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};

export type Subscription = {
  __typename?: 'Subscription';
  ministry?: Maybe<MinistrySubscriptionPayload>;
  minister?: Maybe<MinisterSubscriptionPayload>;
  government?: Maybe<GovernmentSubscriptionPayload>;
  vote?: Maybe<VoteSubscriptionPayload>;
  lobbyist?: Maybe<LobbyistSubscriptionPayload>;
};


export type SubscriptionMinistryArgs = {
  where?: Maybe<MinistrySubscriptionWhereInput>;
};


export type SubscriptionMinisterArgs = {
  where?: Maybe<MinisterSubscriptionWhereInput>;
};


export type SubscriptionGovernmentArgs = {
  where?: Maybe<GovernmentSubscriptionWhereInput>;
};


export type SubscriptionVoteArgs = {
  where?: Maybe<VoteSubscriptionWhereInput>;
};


export type SubscriptionLobbyistArgs = {
  where?: Maybe<LobbyistSubscriptionWhereInput>;
};

export type Vote = {
  __typename?: 'Vote';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  minister?: Maybe<Minister>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
  ministerId?: Maybe<Scalars['ID']>;
};

export type VoteConnection = {
  __typename?: 'VoteConnection';
  pageInfo: PageInfo;
  edges: Array<Maybe<VoteEdge>>;
  aggregate: AggregateVote;
};

export type VoteCreateInput = {
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  minister?: Maybe<MinisterCreateOneWithoutVotesInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type VoteCreateManyWithoutMinisterInput = {
  create?: Maybe<Array<VoteCreateWithoutMinisterInput>>;
  connect?: Maybe<Array<VoteWhereUniqueInput>>;
};

export type VoteCreateWithoutMinisterInput = {
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type VoteEdge = {
  __typename?: 'VoteEdge';
  node: Vote;
  cursor: Scalars['String'];
};

export enum VoteOrderByInput {
  ID_ASC = 'id_ASC',
  ID_DESC = 'id_DESC',
  NAME_ASC = 'name_ASC',
  NAME_DESC = 'name_DESC',
  BALLOT_ASC = 'ballot_ASC',
  BALLOT_DESC = 'ballot_DESC',
  LAWINFO_ASC = 'lawInfo_ASC',
  LAWINFO_DESC = 'lawInfo_DESC',
  LAWINFOJSON_ASC = 'lawInfoJson_ASC',
  LAWINFOJSON_DESC = 'lawInfoJson_DESC',
  CREATEDAT_ASC = 'createdAt_ASC',
  CREATEDAT_DESC = 'createdAt_DESC',
  UPDATEDAT_ASC = 'updatedAt_ASC',
  UPDATEDAT_DESC = 'updatedAt_DESC',
  DELETEDAT_ASC = 'deletedAt_ASC',
  DELETEDAT_DESC = 'deletedAt_DESC',
  DELETED_ASC = 'deleted_ASC',
  DELETED_DESC = 'deleted_DESC'
}

export type VotePreviousValues = {
  __typename?: 'VotePreviousValues';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted: Scalars['Int'];
};

export type VoteScalarWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  ballot_not?: Maybe<Ballot>;
  ballot_in?: Maybe<Array<Ballot>>;
  ballot_not_in?: Maybe<Array<Ballot>>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<VoteScalarWhereInput>>;
  OR?: Maybe<Array<VoteScalarWhereInput>>;
  NOT?: Maybe<Array<VoteScalarWhereInput>>;
};

export type VoteSubscriptionPayload = {
  __typename?: 'VoteSubscriptionPayload';
  mutation: MutationType;
  node?: Maybe<Vote>;
  updatedFields?: Maybe<Array<Scalars['String']>>;
  previousValues?: Maybe<VotePreviousValues>;
};

export type VoteSubscriptionWhereInput = {
  mutation_in?: Maybe<Array<MutationType>>;
  updatedFields_contains?: Maybe<Scalars['String']>;
  updatedFields_contains_every?: Maybe<Array<Scalars['String']>>;
  updatedFields_contains_some?: Maybe<Array<Scalars['String']>>;
  node?: Maybe<VoteWhereInput>;
  AND?: Maybe<Array<VoteSubscriptionWhereInput>>;
  OR?: Maybe<Array<VoteSubscriptionWhereInput>>;
  NOT?: Maybe<Array<VoteSubscriptionWhereInput>>;
};

export type VoteUpdateInput = {
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  minister?: Maybe<MinisterUpdateOneWithoutVotesInput>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type VoteUpdateManyDataInput = {
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type VoteUpdateManyMutationInput = {
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type VoteUpdateManyWithoutMinisterInput = {
  create?: Maybe<Array<VoteCreateWithoutMinisterInput>>;
  delete?: Maybe<Array<VoteWhereUniqueInput>>;
  connect?: Maybe<Array<VoteWhereUniqueInput>>;
  set?: Maybe<Array<VoteWhereUniqueInput>>;
  disconnect?: Maybe<Array<VoteWhereUniqueInput>>;
  update?: Maybe<Array<VoteUpdateWithWhereUniqueWithoutMinisterInput>>;
  upsert?: Maybe<Array<VoteUpsertWithWhereUniqueWithoutMinisterInput>>;
  deleteMany?: Maybe<Array<VoteScalarWhereInput>>;
  updateMany?: Maybe<Array<VoteUpdateManyWithWhereNestedInput>>;
};

export type VoteUpdateManyWithWhereNestedInput = {
  where: VoteScalarWhereInput;
  data: VoteUpdateManyDataInput;
};

export type VoteUpdateWithoutMinisterDataInput = {
  name?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  lawInfo?: Maybe<Scalars['Json']>;
  lawInfoJson?: Maybe<Scalars['Json']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
};

export type VoteUpdateWithWhereUniqueWithoutMinisterInput = {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutMinisterDataInput;
};

export type VoteUpsertWithWhereUniqueWithoutMinisterInput = {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutMinisterDataInput;
  create: VoteCreateWithoutMinisterInput;
};

export type VoteWhereInput = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  id_lt?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_contains?: Maybe<Scalars['ID']>;
  id_not_contains?: Maybe<Scalars['ID']>;
  id_starts_with?: Maybe<Scalars['ID']>;
  id_not_starts_with?: Maybe<Scalars['ID']>;
  id_ends_with?: Maybe<Scalars['ID']>;
  id_not_ends_with?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  name_not?: Maybe<Scalars['String']>;
  name_in?: Maybe<Array<Scalars['String']>>;
  name_not_in?: Maybe<Array<Scalars['String']>>;
  name_lt?: Maybe<Scalars['String']>;
  name_lte?: Maybe<Scalars['String']>;
  name_gt?: Maybe<Scalars['String']>;
  name_gte?: Maybe<Scalars['String']>;
  name_contains?: Maybe<Scalars['String']>;
  name_not_contains?: Maybe<Scalars['String']>;
  name_starts_with?: Maybe<Scalars['String']>;
  name_not_starts_with?: Maybe<Scalars['String']>;
  name_ends_with?: Maybe<Scalars['String']>;
  name_not_ends_with?: Maybe<Scalars['String']>;
  ballot?: Maybe<Ballot>;
  ballot_not?: Maybe<Ballot>;
  ballot_in?: Maybe<Array<Ballot>>;
  ballot_not_in?: Maybe<Array<Ballot>>;
  minister?: Maybe<MinisterWhereInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  createdAt_not?: Maybe<Scalars['DateTime']>;
  createdAt_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  createdAt_lt?: Maybe<Scalars['DateTime']>;
  createdAt_lte?: Maybe<Scalars['DateTime']>;
  createdAt_gt?: Maybe<Scalars['DateTime']>;
  createdAt_gte?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  updatedAt_not?: Maybe<Scalars['DateTime']>;
  updatedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  updatedAt_lt?: Maybe<Scalars['DateTime']>;
  updatedAt_lte?: Maybe<Scalars['DateTime']>;
  updatedAt_gt?: Maybe<Scalars['DateTime']>;
  updatedAt_gte?: Maybe<Scalars['DateTime']>;
  deletedAt?: Maybe<Scalars['DateTime']>;
  deletedAt_not?: Maybe<Scalars['DateTime']>;
  deletedAt_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_not_in?: Maybe<Array<Scalars['DateTime']>>;
  deletedAt_lt?: Maybe<Scalars['DateTime']>;
  deletedAt_lte?: Maybe<Scalars['DateTime']>;
  deletedAt_gt?: Maybe<Scalars['DateTime']>;
  deletedAt_gte?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Int']>;
  deleted_not?: Maybe<Scalars['Int']>;
  deleted_in?: Maybe<Array<Scalars['Int']>>;
  deleted_not_in?: Maybe<Array<Scalars['Int']>>;
  deleted_lt?: Maybe<Scalars['Int']>;
  deleted_lte?: Maybe<Scalars['Int']>;
  deleted_gt?: Maybe<Scalars['Int']>;
  deleted_gte?: Maybe<Scalars['Int']>;
  AND?: Maybe<Array<VoteWhereInput>>;
  OR?: Maybe<Array<VoteWhereInput>>;
  NOT?: Maybe<Array<VoteWhereInput>>;
};

export type VoteWhereUniqueInput = {
  id?: Maybe<Scalars['ID']>;
};
"
`;

exports[`generateDaoSchema generate files should be match to snapshots 9`] = `
"export const whitelistSchema = \`type Query {
  ministry(where: MinistryWhereUniqueInput!): Ministry
}

type Ministry {
  id: ID!
  name: String
  budget: Float
  minister: Minister
  government: Government
  domains: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input MinistryWhereUniqueInput {
  id: ID
}

type Minister {
  id: ID!
  name: String
  votes(where: VoteWhereInput, orderBy: VoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vote!]
  ministry: Ministry
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

type Government {
  id: ID!
  name: String
  country: String
  ministries(where: MinistryWhereInput, orderBy: MinistryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ministry!]
  lobbyists(where: LobbyistWhereInput, orderBy: LobbyistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lobbyist!]
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

scalar DateTime

type Vote {
  id: ID!
  name: String
  ballot: BALLOT
  lawInfo: Json
  lawInfoJson: Json
  minister: Minister
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input VoteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  ballot: BALLOT
  ballot_not: BALLOT
  ballot_in: [BALLOT!]
  ballot_not_in: [BALLOT!]
  minister: MinisterWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [VoteWhereInput!]
  OR: [VoteWhereInput!]
  NOT: [VoteWhereInput!]
}

enum VoteOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  ballot_ASC
  ballot_DESC
  lawInfo_ASC
  lawInfo_DESC
  lawInfoJson_ASC
  lawInfoJson_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

input MinistryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  budget: Float
  budget_not: Float
  budget_in: [Float!]
  budget_not_in: [Float!]
  budget_lt: Float
  budget_lte: Float
  budget_gt: Float
  budget_gte: Float
  minister: MinisterWhereInput
  government: GovernmentWhereInput
  domains_contains: String
  domains_contains_some: [String!]
  domains_contains_every: [String!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [MinistryWhereInput!]
  OR: [MinistryWhereInput!]
  NOT: [MinistryWhereInput!]
}

enum MinistryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  budget_ASC
  budget_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

type Lobbyist {
  id: ID!
  name: String
  governments(where: GovernmentWhereInput, orderBy: GovernmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Government!]
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deleted: Int!
}

input LobbyistWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  governments_every: GovernmentWhereInput
  governments_some: GovernmentWhereInput
  governments_none: GovernmentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [LobbyistWhereInput!]
  OR: [LobbyistWhereInput!]
  NOT: [LobbyistWhereInput!]
}

enum LobbyistOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}

enum BALLOT {
  YEA
  NAY
  ABSTAIN
}

scalar Json

input MinisterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  votes_every: VoteWhereInput
  votes_some: VoteWhereInput
  votes_none: VoteWhereInput
  ministry: MinistryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [MinisterWhereInput!]
  OR: [MinisterWhereInput!]
  NOT: [MinisterWhereInput!]
}

input GovernmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  ministries_every: MinistryWhereInput
  ministries_some: MinistryWhereInput
  ministries_none: MinistryWhereInput
  lobbyists_every: LobbyistWhereInput
  lobbyists_some: LobbyistWhereInput
  lobbyists_none: LobbyistWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  deletedAt: DateTime
  deletedAt_not: DateTime
  deletedAt_in: [DateTime!]
  deletedAt_not_in: [DateTime!]
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deleted: Int
  deleted_not: Int
  deleted_in: [Int!]
  deleted_not_in: [Int!]
  deleted_lt: Int
  deleted_lte: Int
  deleted_gt: Int
  deleted_gte: Int
  AND: [GovernmentWhereInput!]
  OR: [GovernmentWhereInput!]
  NOT: [GovernmentWhereInput!]
}

enum GovernmentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  country_ASC
  country_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  deleted_ASC
  deleted_DESC
}
\`;
"
`;
